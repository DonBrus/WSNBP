###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         31/Jan/2019  15:13:42
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\Application\Utilities\Display.c
#    Command line =  
#        -f C:\Users\Brus\AppData\Local\Temp\EWDC8F.tmp
#        ("D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\Application\Utilities\Display.c" -D NDEBUG -D F24MHZ -D
#        SECURITY_ENABLED -D MC13226Included_d=0 --preprocess=cs
#        "D:\Users\Brus\Documents\my_conn_test\Connectivity Test\Release\List"
#        -lC "D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\Release\List" -lB
#        "D:\Users\Brus\Documents\my_conn_test\Connectivity Test\Release\List"
#        --diag_suppress Pe014,Pe001,Pe991,Pa039 -o
#        "D:\Users\Brus\Documents\my_conn_test\Connectivity Test\Release\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --endian=little --cpu=ARM7TDMI-S
#        --fpu=None --dlib_config "C:\HDDPrograms\IAR Systems\Embedded
#        Workbench 8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        "D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\SMAC\Drivers\Interface\" -I
#        "D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\PLM\Interface\" --cpu_mode thumb -On --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\Release\List\Display.lst
#    Object file  =  
#        D:\Users\Brus\Documents\my_conn_test\Connectivity
#        Test\Release\Obj\Display.o
#
###############################################################################

D:\Users\Brus\Documents\my_conn_test\Connectivity Test\Application\Utilities\Display.c
      1          /************************************************************************************
      2          * This is the source file for Display Driver.
      3          *
      4          *
      5          * (c) Copyright 2008, Freescale, Inc.  All rights reserved.
      6          *
      7          *
      8          * No part of this document must be reproduced in any form - including copied,
      9          * transcribed, printed or by any electronic means - without specific written
     10          * permission from Freescale Semiconductor.
     11          ************************************************************************************/
     12          
     13          #include "../../PLM/Interface/EmbeddedTypes.h"
     14          #include "../../PLM/LibInterface/GPIO_Interface.h"
     15          #include "../../SMAC/Drivers/Interface/Delay.h"
     16          #include "Display.h"
     17          #define gLcdBackLightEnabled_d 1
     18          #if (gLCDSupported_d)
     19          
     20          
     21          
     22          /************************************************************************************
     23          *************************************************************************************
     24          * Private macros
     25          *************************************************************************************
     26          ************************************************************************************/
     27          
     28          /* pin defines */
     29          
     30          /* D0  = SPI_SS    (GPIO  4) , PORT LO */
     31          /* D1  = SPI_MISO  (GPIO  5) , PORT LO */
     32          /* D2  = SPI_MOSI  (GPIO  6) , PORT LO */
     33          /* D3  = SPI_SCK   (GPIO  7) , PORT LO */
     34          /* D4  = ADC2      (GPIO  32), PORT HI */
     35          /* D5  = ADC3      (GPIO  33), PORT HI */
     36          /* D6  = ADC4      (GPIO  34), PORT HI */
     37          /* D7  = ADC5      (GPIO  35), PORT HI */
     38          #define LCD_D0  gGpioPin4_c
     39          #define LCD_D1  gGpioPin5_c
     40          #define LCD_D2  gGpioPin6_c
     41          #define LCD_D3  gGpioPin7_c
     42          #define LCD_D4  gGpioPin32_c
     43          #define LCD_D5  gGpioPin33_c
     44          #define LCD_D6  gGpioPin34_c
     45          #define LCD_D7  gGpioPin35_c
     46          
     47          #define LCD_DATA_LO_MASK  0x000000F0
     48          #define LCD_DATA_LO_PORT  gGpioPort0_c
     49          #define LCD_DATA_LO_WRITE(x) (x)<<4
     50          #define LCD_DATA_LO_READ(x)  (x)>>4
     51          
     52          #define LCD_DATA_HI_MASK  0x0000000F
     53          #define LCD_DATA_HI_PORT  gGpioPort1_c
     54          #define LCD_DATA_HI_WRITE(x) (x)>>4
     55          #define LCD_DATA_HI_READ(x)  (x)<<4
     56          
     57          /* A0     = UART2_RTS (GPIO  21)   inverted, 0-data, 1-command */
     58          /* RD     = TMR0      (GPIO  8)    double inverted, active high */
     59          /* WR     = TMR1      (GPIO  9)    double inverted, active high */
     60          /* CS     = UART2_CTS (GPIO  20)   double inverted, active high */
     61          /* BL_PWM = TMR2      (GPIO  10)   1 - light, 0 - dark or PWM variable duty cycle */
     62          /* RST    = RX_ON     (GPIO  45)   active low */
     63          /* RST    = UART2_RX  (GPIO  19)   active low */
     64          #define LCD_A0          gGpioPin21_c
     65          #define LCD_RD          gGpioPin8_c
     66          #define LCD_WR          gGpioPin9_c
     67          #define LCD_CS          gGpioPin20_c
     68          #define LCD_BL_PWM      gGpioPin10_c
     69          #define LCD_RSTN        gGpioPin45_c
     70          #define LCD_RSTN_debug  gGpioPin19_c
     71          
     72          
     73          /* pin states */
     74          #define LCD_A0_COMMAND  gGpioPinStateHigh_c
     75          #define LCD_A0_DATA     gGpioPinStateLow_c
     76          #define LCD_CS_ACTIVE   gGpioPinStateHigh_c
     77          #define LCD_CS_INACTIVE gGpioPinStateLow_c
     78          #define LCD_WR_ACTIVE   gGpioPinStateHigh_c
     79          #define LCD_WR_INACTIVE gGpioPinStateLow_c
     80          #define LCD_RD_ACTIVE   gGpioPinStateHigh_c
     81          #define LCD_RD_INACTIVE gGpioPinStateLow_c
     82          #define LCD_BL_ON       gGpioPinStateHigh_c
     83          #define LCD_BL_OFF      gGpioPinStateLow_c
     84          #define LCD_RSTN_IDLE   gGpioPinStateHigh_c
     85          #define LCD_RSTN_RESET  gGpioPinStateLow_c
     86          
     87          #define ON                      1
     88          #define OFF                     0
     89          
     90          #define mFontOffset_c          32
     91          
     92          /* number of columns to be cleared in LCD_Task */
     93          #define mMaxDeleteColumns_c    32
     94          #define mMaxLineNumber_c        8
     95          #define mMaxQueueEntries_c     10
     96          #define mEmptyQueue_c          0xFF
     97          
     98          /* number of characters to be displayed in LCD_Task */
     99          #define mNumberOfCharToWrite_c  19
    100          
    101          /************************************************************************************
    102          *************************************************************************************
    103          * Private type definitions
    104          *************************************************************************************
    105          ************************************************************************************/
    106          /* #pragma pack(1) */
    107          
    108          typedef struct displayParams_tag{
    109            uint8_t currentXCoord;
    110            uint8_t currentYCoord;
    111            uint8_t currentLine;
    112            /* Bitmask: 
    113            *       line i is cleared, bit i from writtenLines is 0
    114            *       line i is written, bit i from writtenLines is 1 
    115            */
    116            uint8_t writtenLines;
    117            /* Bitmask: 
    118            *       line i will not be written, bit i from linesToWrite is 0
    119            *       line i will be written, bit i from linesToWrite is 1 
    120            */
    121            uint8_t linesToWrite;  
    122            uint8_t linesWidthWritten[mMaxLineNumber_c];
    123            uint8_t currentFontType;
    124            uint8_t currentStringIndex;
    125            uint8_t currentString[mMaxLineNumber_c][gMAX_LCD_CHARS_c];
    126          }displayParams_t;
    127          
    128          typedef struct lineParams_tag{
    129            uint8_t xCoord;
    130            uint8_t yCoord;
    131            uint8_t page;  
    132          }lineParams_t;
    133          
    134          typedef struct pageParams_tag{
    135            uint8_t xStartCoord;
    136            uint8_t xEndCoord;
    137            uint8_t yCoord;
    138            uint8_t line;
    139          }pageParams_t;
    140          
    141          typedef enum operation_tag{
    142            gLCD_WriteOp_c = 0,
    143            gLCD_ClearDisplayOp_c,
    144            gLCD_ClearLineOp_c,
    145            gLCD_MaxOp_c = 0xFF
    146          }operation_t;
    147          
    148          typedef struct opLine_tag{
    149            operation_t opQueue;
    150            uint8_t lineQueue;  
    151          }opLine_t;
    152          
    153          typedef struct queue_tag{
    154            uint8_t head;
    155            uint8_t tail;
    156            opLine_t opLine[mMaxQueueEntries_c];
    157          }queue_t;
    158          
    159          /* #pragma pack() */
    160          
    161          /************************************************************************************
    162          *************************************************************************************
    163          * Private prototypes
    164          *************************************************************************************
    165          ************************************************************************************/
    166          
    167          void LCD_SetBacklight(uint8_t brightnessValue);
    168          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord);
    169          uint8_t LCD_ClearLine(uint8_t line);
    170          static void SendData(uint8_t data);
    171          static void SetHiZ(void);
    172          static void SetOutput(void);
    173          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord);
    174          static uint8_t ReadData(void);
    175          static uint8_t GetData(void);
    176          static uint8_t GetStrlen(const uint8_t *pString);
    177          
    178          
    179          /************************************************************************************
    180          *************************************************************************************
    181          * Private memory declarations
    182          *************************************************************************************
    183          ************************************************************************************/
    184          

   \                                 In section .data, align 4
    185          static displayParams_t mDisplayParams = {
   \                     mDisplayParams:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0xFF    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x16   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x44   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x5B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x72   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x89   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xA0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xB7   0x00               DC8 0
    186            /* currentXCoord */
    187            0x00,
    188            /* currentYCoord */
    189            0x00,
    190            /* currentLine */
    191            0x00,
    192            /* writtenLines */
    193            0xFF,
    194            /* linesToWrite */
    195            0x00,
    196            /* linesWidthWritten */
    197            0x00,
    198            /* currentFontType */
    199            0x00,
    200            /* currentStringIndex */
    201            0x00,  
    202            /* currentString */
    203            0x00
    204          };
    205          

   \                                 In section .data, align 4
    206          static lineParams_t mLineParams[mMaxLineNumber_c] = {
   \                     mLineParams:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 8, 1, 0, 16, 2, 0, 24, 3, 0, 32, 4, 0, 40, 5, 0, 48, 6
   \              0x00 0x00    
   \              0x08 0x01    
   \              0x00 0x10    
   \              0x02 0x00    
   \              0x18 0x03    
   \              0x00 0x20    
   \              0x04 0x00    
   \              0x28 0x05    
   \              0x00 0x30    
   \              0x06         
   \       0x15   0x00 0x38          DC8 0, 56, 7
   \              0x07         
    207            {0, 0, 0},
    208            {0, 8, 1},
    209            {0, 16, 2},
    210            {0, 24, 3},
    211            {0, 32, 4},
    212            {0, 40, 5},
    213            {0, 48, 6},
    214            {0, 56, 7},
    215          };  
    216          
    217          
    218          /* after initialization, all LCD lines must be erased */

   \                                 In section .bss, align 1
    219          static bool_t mIsLcdInitialized = FALSE;
   \                     mIsLcdInitialized:
   \        0x0                      DS8 1
    220          
    221          /* error indicator, used for error reporting */

   \                                 In section .bss, align 1
    222          static volatile lcdError_t mErrorIndicator = gLCD_NoError_c;
   \                     mErrorIndicator:
   \        0x0                      DS8 1
    223          
    224          /******************************************************************************
    225          *******************************************************************************
    226          * Public memory definitions
    227          *******************************************************************************
    228          ******************************************************************************/
    229          

   \                                 In section .rodata, align 4
    230          const uint8_t gaHexValue[] = "0123456789ABCDEF";
   \                     gaHexValue:
   \        0x0   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    231          

   \                                 In section .rodata, align 4
    232          const font_t aLCDFont[gLCDNumFonts_c] = 
   \                     aLCDFont:
   \        0x0   0x....'....        DC32 gLCDNormalIndex, gLCDNormalFont
   \              0x....'....  
   \        0x8   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \        0xC   0x....'....        DC32 gLCDVerdanaIndex, gLCDVerdanaFont
   \              0x....'....  
   \       0x14   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
    233          {
    234            /* character font with fixed width */ 
    235            {gLCDNormalIndex,  gLCDNormalFont,  1},
    236            /* character font with variable width */ 
    237            {gLCDVerdanaIndex, gLCDVerdanaFont, 2}   
    238          };
    239          
    240          /************************************************************************************
    241          *************************************************************************************
    242          * Public functions
    243          *************************************************************************************
    244          ************************************************************************************/
    245          
    246          /******************************************************************************
    247          * This function initializes the display
    248          *
    249          * Interface assumptions:
    250          *
    251          *
    252          * Return value:
    253          * None
    254          *
    255          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    256          void LCD_Init(void)
    257          {
   \                     LCD_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    258          
    259              Gpio_SetPinFunction(LCD_WR, gGpioNormalMode_c);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2009             MOVS     R0,#+9
   \        0x6   0x....'....        BL       Gpio_SetPinFunction
    260              Gpio_SetPinFunction(LCD_CS, gGpioNormalMode_c);
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2014             MOVS     R0,#+20
   \        0xE   0x....'....        BL       Gpio_SetPinFunction
    261              Gpio_SetPinFunction(LCD_RD, gGpioNormalMode_c);
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x2008             MOVS     R0,#+8
   \       0x16   0x....'....        BL       Gpio_SetPinFunction
    262              Gpio_SetPinFunction(LCD_A0, gGpioNormalMode_c);
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x2015             MOVS     R0,#+21
   \       0x1E   0x....'....        BL       Gpio_SetPinFunction
    263              Gpio_SetPinFunction(LCD_RSTN, gGpioNormalMode_c);
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x202D             MOVS     R0,#+45
   \       0x26   0x....'....        BL       Gpio_SetPinFunction
    264              Gpio_SetPinFunction(LCD_RSTN_debug, gGpioNormalMode_c);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x2013             MOVS     R0,#+19
   \       0x2E   0x....'....        BL       Gpio_SetPinFunction
    265          
    266              Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x2009             MOVS     R0,#+9
   \       0x36   0x....'....        BL       Gpio_SetPinData
    267              Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x2014             MOVS     R0,#+20
   \       0x3E   0x....'....        BL       Gpio_SetPinData
    268              Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x2008             MOVS     R0,#+8
   \       0x46   0x....'....        BL       Gpio_SetPinData
    269              Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
   \       0x4A   0x2101             MOVS     R1,#+1
   \       0x4C   0x2015             MOVS     R0,#+21
   \       0x4E   0x....'....        BL       Gpio_SetPinData
    270              Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x202D             MOVS     R0,#+45
   \       0x56   0x....'....        BL       Gpio_SetPinData
    271              Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x2013             MOVS     R0,#+19
   \       0x5E   0x....'....        BL       Gpio_SetPinData
    272          
    273              /* define the LCD pins as output pins */
    274              (void)Gpio_SetPinReadSource(LCD_CS,     gGpioPinReadReg_c);
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0x2014             MOVS     R0,#+20
   \       0x66   0x....'....        BL       Gpio_SetPinReadSource
    275              (void)Gpio_SetPinReadSource(LCD_A0,     gGpioPinReadReg_c);
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x2015             MOVS     R0,#+21
   \       0x6E   0x....'....        BL       Gpio_SetPinReadSource
    276              (void)Gpio_SetPinReadSource(LCD_RD,     gGpioPinReadReg_c);
   \       0x72   0x2101             MOVS     R1,#+1
   \       0x74   0x2008             MOVS     R0,#+8
   \       0x76   0x....'....        BL       Gpio_SetPinReadSource
    277              (void)Gpio_SetPinReadSource(LCD_WR,     gGpioPinReadReg_c);
   \       0x7A   0x2101             MOVS     R1,#+1
   \       0x7C   0x2009             MOVS     R0,#+9
   \       0x7E   0x....'....        BL       Gpio_SetPinReadSource
    278              (void)Gpio_SetPinReadSource(LCD_BL_PWM, gGpioPinReadReg_c);
   \       0x82   0x2101             MOVS     R1,#+1
   \       0x84   0x200A             MOVS     R0,#+10
   \       0x86   0x....'....        BL       Gpio_SetPinReadSource
    279              (void)Gpio_SetPinReadSource(LCD_RSTN,   gGpioPinReadReg_c);
   \       0x8A   0x2101             MOVS     R1,#+1
   \       0x8C   0x202D             MOVS     R0,#+45
   \       0x8E   0x....'....        BL       Gpio_SetPinReadSource
    280              (void)Gpio_SetPinReadSource(LCD_RSTN_debug,   gGpioPinReadReg_c);
   \       0x92   0x2101             MOVS     R1,#+1
   \       0x94   0x2013             MOVS     R0,#+19
   \       0x96   0x....'....        BL       Gpio_SetPinReadSource
    281          
    282              (void)Gpio_SetPinDir(LCD_CS,     gGpioDirOut_c);
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0x2014             MOVS     R0,#+20
   \       0x9E   0x....'....        BL       Gpio_SetPinDir
    283              (void)Gpio_SetPinDir(LCD_A0,     gGpioDirOut_c);
   \       0xA2   0x2101             MOVS     R1,#+1
   \       0xA4   0x2015             MOVS     R0,#+21
   \       0xA6   0x....'....        BL       Gpio_SetPinDir
    284              (void)Gpio_SetPinDir(LCD_RD,     gGpioDirOut_c);
   \       0xAA   0x2101             MOVS     R1,#+1
   \       0xAC   0x2008             MOVS     R0,#+8
   \       0xAE   0x....'....        BL       Gpio_SetPinDir
    285              (void)Gpio_SetPinDir(LCD_WR,     gGpioDirOut_c);
   \       0xB2   0x2101             MOVS     R1,#+1
   \       0xB4   0x2009             MOVS     R0,#+9
   \       0xB6   0x....'....        BL       Gpio_SetPinDir
    286              (void)Gpio_SetPinDir(LCD_BL_PWM, gGpioDirOut_c);
   \       0xBA   0x2101             MOVS     R1,#+1
   \       0xBC   0x200A             MOVS     R0,#+10
   \       0xBE   0x....'....        BL       Gpio_SetPinDir
    287              (void)Gpio_SetPinDir(LCD_RSTN,   gGpioDirOut_c);
   \       0xC2   0x2101             MOVS     R1,#+1
   \       0xC4   0x202D             MOVS     R0,#+45
   \       0xC6   0x....'....        BL       Gpio_SetPinDir
    288              (void)Gpio_SetPinDir(LCD_RSTN_debug,   gGpioDirOut_c);
   \       0xCA   0x2101             MOVS     R1,#+1
   \       0xCC   0x2013             MOVS     R0,#+19
   \       0xCE   0x....'....        BL       Gpio_SetPinDir
    289          
    290              /* data pins */
    291          #if gLCDGpioPinMode_c
    292              (void)Gpio_SetPinFunction(LCD_D0,      gGpioNormalMode_c);
    293              (void)Gpio_SetPinFunction(LCD_D1,      gGpioNormalMode_c);
    294              (void)Gpio_SetPinFunction(LCD_D2,      gGpioNormalMode_c);
    295              (void)Gpio_SetPinFunction(LCD_D3,      gGpioNormalMode_c);
    296              (void)Gpio_SetPinFunction(LCD_D4,      gGpioNormalMode_c);
    297              (void)Gpio_SetPinFunction(LCD_D5,      gGpioNormalMode_c);
    298              (void)Gpio_SetPinFunction(LCD_D6,      gGpioNormalMode_c);
    299              (void)Gpio_SetPinFunction(LCD_D7,      gGpioNormalMode_c);
    300          
    301              /* define data pins as inputs */
    302              (void)Gpio_EnPinPullup(LCD_D0,      TRUE);
    303              (void)Gpio_EnPinPullup(LCD_D1,      TRUE);
    304              (void)Gpio_EnPinPullup(LCD_D2,      TRUE);
    305              (void)Gpio_EnPinPullup(LCD_D3,      TRUE);
    306              (void)Gpio_EnPinPullup(LCD_D4,      TRUE);
    307              (void)Gpio_EnPinPullup(LCD_D5,      TRUE);
    308              (void)Gpio_EnPinPullup(LCD_D6,      TRUE);
    309              (void)Gpio_EnPinPullup(LCD_D7,      TRUE);
    310          
    311              (void)Gpio_SelectPinPullup(LCD_D0,      gGpioPinPullup_c);
    312              (void)Gpio_SelectPinPullup(LCD_D1,      gGpioPinPullup_c);
    313              (void)Gpio_SelectPinPullup(LCD_D2,      gGpioPinPullup_c);
    314              (void)Gpio_SelectPinPullup(LCD_D3,      gGpioPinPullup_c);
    315              (void)Gpio_SelectPinPullup(LCD_D4,      gGpioPinPullup_c);
    316              (void)Gpio_SelectPinPullup(LCD_D5,      gGpioPinPullup_c);
    317              (void)Gpio_SelectPinPullup(LCD_D6,      gGpioPinPullup_c);
    318              (void)Gpio_SelectPinPullup(LCD_D7,      gGpioPinPullup_c);
    319          
    320              (void)Gpio_EnPinPuKeeper(LCD_D0,      TRUE);
    321              (void)Gpio_EnPinPuKeeper(LCD_D1,      TRUE);
    322              (void)Gpio_EnPinPuKeeper(LCD_D2,      TRUE);
    323              (void)Gpio_EnPinPuKeeper(LCD_D3,      TRUE);
    324              (void)Gpio_EnPinPuKeeper(LCD_D4,      TRUE);
    325              (void)Gpio_EnPinPuKeeper(LCD_D5,      TRUE);
    326              (void)Gpio_EnPinPuKeeper(LCD_D6,      TRUE);
    327              (void)Gpio_EnPinPuKeeper(LCD_D7,      TRUE);
    328          
    329              (void)Gpio_SetPinReadSource(LCD_D0,      gGpioPinReadPad_c);
    330              (void)Gpio_SetPinReadSource(LCD_D1,      gGpioPinReadPad_c);
    331              (void)Gpio_SetPinReadSource(LCD_D2,      gGpioPinReadPad_c);
    332              (void)Gpio_SetPinReadSource(LCD_D3,      gGpioPinReadPad_c);
    333              (void)Gpio_SetPinReadSource(LCD_D4,      gGpioPinReadPad_c);
    334              (void)Gpio_SetPinReadSource(LCD_D5,      gGpioPinReadPad_c);
    335              (void)Gpio_SetPinReadSource(LCD_D6,      gGpioPinReadPad_c);
    336              (void)Gpio_SetPinReadSource(LCD_D7,      gGpioPinReadPad_c);
    337          
    338              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
    339              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
    340              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
    341              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
    342              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
    343              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
    344              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
    345              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
    346          #else /* gLCDGpioPinMode_c */
    347              Gpio_SetPortFunction(LCD_DATA_LO_PORT, gGpioNormalMode_c, LCD_DATA_LO_MASK);
   \       0xD2   0x22F0             MOVS     R2,#+240
   \       0xD4   0x2100             MOVS     R1,#+0
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x....'....        BL       Gpio_SetPortFunction
    348              Gpio_SetPortFunction(LCD_DATA_HI_PORT, gGpioNormalMode_c, LCD_DATA_HI_MASK);
   \       0xDC   0x220F             MOVS     R2,#+15
   \       0xDE   0x2100             MOVS     R1,#+0
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x....'....        BL       Gpio_SetPortFunction
    349          
    350              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpEnAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \       0xE6   0x23F0             MOVS     R3,#+240
   \       0xE8   0x22F0             MOVS     R2,#+240
   \       0xEA   0x2103             MOVS     R1,#+3
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x....'....        BL       Gpio_WrPortSetting
    351              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpEnAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \       0xF2   0x230F             MOVS     R3,#+15
   \       0xF4   0x220F             MOVS     R2,#+15
   \       0xF6   0x2103             MOVS     R1,#+3
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0x....'....        BL       Gpio_WrPortSetting
    352          
    353              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpSelAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \       0xFE   0x23F0             MOVS     R3,#+240
   \      0x100   0x22F0             MOVS     R2,#+240
   \      0x102   0x2104             MOVS     R1,#+4
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x....'....        BL       Gpio_WrPortSetting
    354              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpSelAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \      0x10A   0x230F             MOVS     R3,#+15
   \      0x10C   0x220F             MOVS     R2,#+15
   \      0x10E   0x2104             MOVS     R1,#+4
   \      0x110   0x2001             MOVS     R0,#+1
   \      0x112   0x....'....        BL       Gpio_WrPortSetting
    355          
    356              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \      0x116   0x23F0             MOVS     R3,#+240
   \      0x118   0x22F0             MOVS     R2,#+240
   \      0x11A   0x2106             MOVS     R1,#+6
   \      0x11C   0x2000             MOVS     R0,#+0
   \      0x11E   0x....'....        BL       Gpio_WrPortSetting
    357              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \      0x122   0x230F             MOVS     R3,#+15
   \      0x124   0x220F             MOVS     R2,#+15
   \      0x126   0x2106             MOVS     R1,#+6
   \      0x128   0x2001             MOVS     R0,#+1
   \      0x12A   0x....'....        BL       Gpio_WrPortSetting
    358              
    359              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \      0x12E   0x25F0             MOVS     R5,#+240
   \      0x130   0x43ED             MVNS     R5,R5            ;; #-241
   \      0x132   0x23F0             MOVS     R3,#+240
   \      0x134   0x002A             MOVS     R2,R5
   \      0x136   0x2102             MOVS     R1,#+2
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x....'....        BL       Gpio_WrPortSetting
    360              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \      0x13E   0x240F             MOVS     R4,#+15
   \      0x140   0x43E4             MVNS     R4,R4            ;; #-16
   \      0x142   0x230F             MOVS     R3,#+15
   \      0x144   0x0022             MOVS     R2,R4
   \      0x146   0x2102             MOVS     R1,#+2
   \      0x148   0x2001             MOVS     R0,#+1
   \      0x14A   0x....'....        BL       Gpio_WrPortSetting
    361              
    362              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \      0x14E   0x22F0             MOVS     R2,#+240
   \      0x150   0x0029             MOVS     R1,R5
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x....'....        BL       Gpio_SetPortDir
    363              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \      0x158   0x220F             MOVS     R2,#+15
   \      0x15A   0x0021             MOVS     R1,R4
   \      0x15C   0x2001             MOVS     R0,#+1
   \      0x15E   0x....'....        BL       Gpio_SetPortDir
    364          #endif /* gLCDGpioPinMode_c */
    365          
    366          
    367            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_RESET);
   \      0x162   0x2100             MOVS     R1,#+0
   \      0x164   0x202D             MOVS     R0,#+45
   \      0x166   0x....'....        BL       Gpio_SetPinData
    368            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_RESET);
   \      0x16A   0x2100             MOVS     R1,#+0
   \      0x16C   0x2013             MOVS     R0,#+19
   \      0x16E   0x....'....        BL       Gpio_SetPinData
    369            DelayUs(10);
   \      0x172   0x200A             MOVS     R0,#+10
   \      0x174   0x....'....        BL       DelayUs
    370            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
   \      0x178   0x2101             MOVS     R1,#+1
   \      0x17A   0x202D             MOVS     R0,#+45
   \      0x17C   0x....'....        BL       Gpio_SetPinData
    371            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
   \      0x180   0x2101             MOVS     R1,#+1
   \      0x182   0x2013             MOVS     R0,#+19
   \      0x184   0x....'....        BL       Gpio_SetPinData
    372            DelayMs(1);
   \      0x188   0x2001             MOVS     R0,#+1
   \      0x18A   0x....'....        BL       DelayMs
    373          
    374              /* Turn ON the VDD-VSS power keeping the RES pin = LOW for 0.5us */
    375              /* When power is stabilized, relese the RES pin (RES pin = HIGH) */
    376              
    377              /* Default initialized state: 
    378               - Display off
    379          	   - Normal display (COM0 --> COM63)
    380          	   - ADC select: normal (RAM column address n <-> SEGn)
    381          	   - Power control register: Booster circuit OFF, Voltage regulator circuit OFF, Voltage follower circuit OFF
    382          	   - LCD power supply bias rate = 1/9
    383          	   - All-indicator lamps-on OFF
    384          	   - Power saving clear
    385          	   - V5 voltage regulator internal resistors Ra and Rb separation
    386          	   - Output conditions of SEG and COM terminals SEG:V2/V3; COM: V1/V4
    387          	   - Read modify write OFF
    388          	   - Static indicator OFF
    389          	   - Display start line set to first line
    390          	   - Column address set to Address 0
    391          	   - Page address set to Page 0
    392          	   - Common output status normal
    393          	   - V5 voltage regulator internal resistor ratio set mode clear
    394          	   - Electronic volume register set mode clear
    395          	   - Test mode clear 
    396              */
    397          
    398              /* reset display */
    399              LCD_WriteCommand(gLCDResetCommand_c);
   \      0x18E   0x20E2             MOVS     R0,#+226
   \      0x190   0x....'....        BL       LCD_WriteCommand
    400              DelayUs(10);
   \      0x194   0x200A             MOVS     R0,#+10
   \      0x196   0x....'....        BL       DelayUs
    401          
    402              /* set LCD bias to 1/9 */
    403              LCD_WriteCommand(gLCD19BiasCommand_c);
   \      0x19A   0x20A2             MOVS     R0,#+162
   \      0x19C   0x....'....        BL       LCD_WriteCommand
    404          
    405              /* set ADC selection to normal: RAM column address n <-> SEGn */
    406              /* LCD_WriteCommand(gLCDADCNormalCommand_c); */
    407              LCD_WriteCommand(gLCDADCReverseCommand_c);
   \      0x1A0   0x20A1             MOVS     R0,#+161
   \      0x1A2   0x....'....        BL       LCD_WriteCommand
    408          
    409              /* set scan direction of the COM to normal: COM0 --> COM63 */
    410              LCD_WriteCommand(gLCDComNormalCommand_c);
   \      0x1A6   0x20C0             MOVS     R0,#+192
   \      0x1A8   0x....'....        BL       LCD_WriteCommand
    411          
    412              /* set the Rb/Ra ratio for V5 to medium (D2D1D0 = 0b100) */
    413              LCD_WriteCommand( gLCDDefaultRatioCommand_c | (gLCDRatioValue_c & 0x07) );
   \      0x1AC   0x2024             MOVS     R0,#+36
   \      0x1AE   0x....'....        BL       LCD_WriteCommand
    414          
    415              /* enable the electronic volume register set command */
    416              /* this command must always be followed by an electronic volume register set command */
    417              LCD_WriteCommand(gLCDElectronicVolumeModeSetCommand_c);
   \      0x1B2   0x2081             MOVS     R0,#+129
   \      0x1B4   0x....'....        BL       LCD_WriteCommand
    418              
    419              LCD_WriteCommand(gLCDElectronicVolumeInitCommand_c);
   \      0x1B8   0x2030             MOVS     R0,#+48
   \      0x1BA   0x....'....        BL       LCD_WriteCommand
    420          
    421          
    422              /* disable booster circuit, disable voltage regulator circuit, disable voltage follower circuit */
    423              LCD_WriteCommand(0x2F);
   \      0x1BE   0x202F             MOVS     R0,#+47
   \      0x1C0   0x....'....        BL       LCD_WriteCommand
    424              DelayUs(10);
   \      0x1C4   0x200A             MOVS     R0,#+10
   \      0x1C6   0x....'....        BL       DelayUs
    425              /** turn ON */
    426              LCD_WriteCommand(gLCDDisplayOnCommand_c);
   \      0x1CA   0x20AF             MOVS     R0,#+175
   \      0x1CC   0x....'....        BL       LCD_WriteCommand
    427              DelayUs(10);
   \      0x1D0   0x200A             MOVS     R0,#+10
   \      0x1D2   0x....'....        BL       DelayUs
    428              
    429              /* turn on the backlight */
    430              LCD_SetBacklight(gLCDDefaultBrightnessValue_c);
   \      0x1D6   0x200F             MOVS     R0,#+15
   \      0x1D8   0x....'....        BL       LCD_SetBacklight
    431              
    432              /* set default font */
    433              (void)LCD_SetFont(gLCD_NormalFont_c);
   \      0x1DC   0x2000             MOVS     R0,#+0
   \      0x1DE   0x....'....        BL       LCD_SetFont
    434          
    435              mIsLcdInitialized = FALSE;
   \      0x1E2   0x2000             MOVS     R0,#+0
   \      0x1E4   0x....             LDR      R1,??DataTable2
   \      0x1E6   0x7008             STRB     R0,[R1, #+0]
    436          }
   \      0x1E8   0xBC31             POP      {R0,R4,R5}
   \      0x1EA   0xBC08             POP      {R3}
   \      0x1EC   0x4718             BX       R3               ;; return
    437          
    438          /******************************************************************************
    439          * This function clears the display. In case an error occured during add to queue
    440          * operation, the clear display operation will not execute.
    441          *
    442          * Interface assumptions:
    443          *
    444          *
    445          * Return value:
    446          * None
    447          *
    448          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    449          void LCD_ClearDisplay(void)
    450          {
   \                     LCD_ClearDisplay: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    451          
    452            static uint8_t linesToClear = 0x00;
    453            uint8_t line, deleteWriteLines = 0xFF;
   \        0x2   0x20FF             MOVS     R0,#+255
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    454            
    455            /* clear the error indicator */
    456            mErrorIndicator = gLCD_NoError_c;
   \        0x8   0x2500             MOVS     R5,#+0
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x....             LDR      R1,??DataTable2_1
   \        0xE   0x7008             STRB     R0,[R1, #+0]
    457            
    458              
    459           /* determine the lines that were written and need to be cleared */   
    460            linesToClear = mDisplayParams.writtenLines;  
   \       0x10   0x....             LDR      R4,??DataTable2_2
   \       0x12   0x....             LDR      R7,??DataTable2_3
   \       0x14   0x78F8             LDRB     R0,[R7, #+3]
   \       0x16   0x7020             STRB     R0,[R4, #+0]
    461            if(mIsLcdInitialized == TRUE)
   \       0x18   0x....             LDR      R0,??DataTable2
   \       0x1A   0x7800             LDRB     R0,[R0, #+0]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD10D             BNE      ??LCD_ClearDisplay_0
    462            {
    463           /* determine if there are lines that need to be erased and after need to be written */
    464              deleteWriteLines = linesToClear & mDisplayParams.linesToWrite;
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   \       0x22   0x7939             LDRB     R1,[R7, #+4]
   \       0x24   0x4001             ANDS     R1,R1,R0
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x7001             STRB     R1,[R0, #+0]
    465              if(deleteWriteLines)
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x7800             LDRB     R0,[R0, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD004             BEQ      ??LCD_ClearDisplay_0
    466              { /* if there are */
    467               /* mark that lines as deleted and jump over them */
    468                linesToClear &= ~(deleteWriteLines);  
   \       0x32   0x7820             LDRB     R0,[R4, #+0]
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x7809             LDRB     R1,[R1, #+0]
   \       0x38   0x4388             BICS     R0,R0,R1
   \       0x3A   0x7020             STRB     R0,[R4, #+0]
    469              }
    470            }
    471             line = 0;
    472             /* find the first written line */
    473             
    474            do
    475            {
    476              while((!((linesToClear>>line)&0x01))&&(line<mMaxLineNumber_c))
   \                     ??LCD_ClearDisplay_0: (+1)
   \                     ??LCD_ClearDisplay_1: (+1)
   \       0x3C   0x2601             MOVS     R6,#+1
   \       0x3E   0x7820             LDRB     R0,[R4, #+0]
   \       0x40   0x4128             ASRS     R0,R0,R5
   \       0x42   0x4030             ANDS     R0,R0,R6
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD106             BNE      ??LCD_ClearDisplay_2
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x4C   0x0E00             LSRS     R0,R0,#+24
   \       0x4E   0x2808             CMP      R0,#+8
   \       0x50   0xDA01             BGE      ??LCD_ClearDisplay_2
    477              {
    478                line++;
   \       0x52   0x1C6D             ADDS     R5,R5,#+1
   \       0x54   0xE7F2             B        ??LCD_ClearDisplay_1
    479              }
    480             
    481              if(line!= mMaxLineNumber_c)
   \                     ??LCD_ClearDisplay_2: (+1)
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x5A   0x0E00             LSRS     R0,R0,#+24
   \       0x5C   0x2808             CMP      R0,#+8
   \       0x5E   0xD00F             BEQ      ??LCD_ClearDisplay_3
    482              {
    483               /* in case at least a line is written */
    484                if(TRUE == LCD_ClearLine(line))
   \       0x60   0x0028             MOVS     R0,R5
   \       0x62   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x64   0x0E00             LSRS     R0,R0,#+24
   \       0x66   0x....'....        BL       LCD_ClearLine
   \       0x6A   0x2801             CMP      R0,#+1
   \       0x6C   0xD108             BNE      ??LCD_ClearDisplay_3
    485                {
    486                 /* mark line as cleared */
    487                  mDisplayParams.writtenLines &= ~(1 << line);
   \       0x6E   0x78F9             LDRB     R1,[R7, #+3]
   \       0x70   0x0030             MOVS     R0,R6
   \       0x72   0x40A8             LSLS     R0,R0,R5
   \       0x74   0x4381             BICS     R1,R1,R0
   \       0x76   0x70F9             STRB     R1,[R7, #+3]
    488                  linesToClear &= ~(1 << line);
   \       0x78   0x7820             LDRB     R0,[R4, #+0]
   \       0x7A   0x40AE             LSLS     R6,R6,R5
   \       0x7C   0x43B0             BICS     R0,R0,R6
   \       0x7E   0x7020             STRB     R0,[R4, #+0]
    489                 /* check if there are other lines written */
    490                }
    491              }
    492            }while(line!= mMaxLineNumber_c);
   \                     ??LCD_ClearDisplay_3: (+1)
   \       0x80   0x0028             MOVS     R0,R5
   \       0x82   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x84   0x0E00             LSRS     R0,R0,#+24
   \       0x86   0x2808             CMP      R0,#+8
   \       0x88   0xD1D8             BNE      ??LCD_ClearDisplay_1
    493          }
   \       0x8A   0xBCF1             POP      {R0,R4-R7}
   \       0x8C   0xBC08             POP      {R3}
   \       0x8E   0x4718             BX       R3               ;; return

   \                                 In section .bss, align 1
   \                     `LCD_ClearDisplay::linesToClear`:
   \        0x0                      DS8 1
    494          
    495          /******************************************************************************
    496          * This function writes a string to the display. In case an error occured 
    497          * during add to queue operation, the write string operation will not execute.
    498          *
    499          * Interface assumptions:
    500          *
    501          *
    502          * Return value:
    503          * None
    504          *
    505          *
    506          ******************************************************************************/
    507          

   \                                 In section .text, align 2, keep-with-next
    508          void LCD_WriteString_NormalFont(uint8_t line, uint8_t *pstr){
   \                     LCD_WriteString_NormalFont: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
    509           
    510           uint8_t len; 
    511           uint8_t i;
    512           mDisplayParams.currentXCoord = mLineParams[line].xCoord;;  
   \        0x4   0x....             LDR      R6,??DataTable2_3
   \        0x6   0x....             LDR      R0,??DataTable3
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7809             LDRB     R1,[R1, #+0]
   \        0xC   0x2203             MOVS     R2,#+3
   \        0xE   0x4351             MULS     R1,R2,R1
   \       0x10   0x5C41             LDRB     R1,[R0, R1]
   \       0x12   0x7031             STRB     R1,[R6, #+0]
    513           mDisplayParams.currentYCoord = mLineParams[line].yCoord;   
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x7809             LDRB     R1,[R1, #+0]
   \       0x18   0x2203             MOVS     R2,#+3
   \       0x1A   0x4351             MULS     R1,R2,R1
   \       0x1C   0x1840             ADDS     R0,R0,R1
   \       0x1E   0x7840             LDRB     R0,[R0, #+1]
   \       0x20   0x7070             STRB     R0,[R6, #+1]
    514           len = GetStrlen(pstr);
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x....'....        BL       GetStrlen
   \       0x28   0x0007             MOVS     R7,R0
    515           
    516           for(i=0; ((i< len) && (i < gMAX_LCD_CHARS_c)); i++)
   \       0x2A   0x2500             MOVS     R5,#+0
   \                     ??LCD_WriteString_NormalFont_0: (+1)
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x0039             MOVS     R1,R7
   \       0x30   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x32   0x0E00             LSRS     R0,R0,#+24
   \       0x34   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x36   0x0E09             LSRS     R1,R1,#+24
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD20F             BCS      ??LCD_WriteString_NormalFont_1
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x40   0x0E00             LSRS     R0,R0,#+24
   \       0x42   0x2815             CMP      R0,#+21
   \       0x44   0xDA0A             BGE      ??LCD_WriteString_NormalFont_1
    517           {
    518             LCD_WriteCharacter(*pstr,mDisplayParams.currentXCoord, mDisplayParams.currentYCoord);   
   \       0x46   0x7872             LDRB     R2,[R6, #+1]
   \       0x48   0x7831             LDRB     R1,[R6, #+0]
   \       0x4A   0x7820             LDRB     R0,[R4, #+0]
   \       0x4C   0x....'....        BL       LCD_WriteCharacter
    519             mDisplayParams.currentXCoord += 6;
   \       0x50   0x7830             LDRB     R0,[R6, #+0]
   \       0x52   0x1D80             ADDS     R0,R0,#+6
   \       0x54   0x7030             STRB     R0,[R6, #+0]
    520            pstr++;
   \       0x56   0x1C64             ADDS     R4,R4,#+1
    521           }
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
   \       0x5A   0xE7E7             B        ??LCD_WriteString_NormalFont_0
    522          }
   \                     ??LCD_WriteString_NormalFont_1: (+1)
   \       0x5C   0xBCF1             POP      {R0,R4-R7}
   \       0x5E   0xBC08             POP      {R3}
   \       0x60   0x4718             BX       R3               ;; return
    523          
    524          /******************************************************************************
    525          * This function write a string and a value in decimal or hexdecimal
    526          * to the display
    527          *
    528          * Interface assumptions:
    529          * The pstr must be zero-terminated.
    530          *
    531          * Return value:
    532          * None
    533          *
    534          *
    535          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          void LCD_WriteStringValue
    537            (
    538            uint8_t *pstr,     /* IN: Pointer to text string */
    539            uint16_t value,    /* IN: Value */
    540            uint8_t line, 	   /* IN: Line in display */
    541            LCD_t numberFormat /* IN: Value to show in HEX or DEC */
    542            )
    543          {
   \                     LCD_WriteStringValue: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB08E             SUB      SP,SP,#+56
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
    544          
    545            int16_t divDec=10000, divHex=16;
   \        0x8   0x....             LDR      R0,??DataTable3_1  ;; 0x2710
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x80C8             STRH     R0,[R1, #+6]
   \        0xE   0x2010             MOVS     R0,#+16
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x8108             STRH     R0,[R1, #+8]
    546            uint8_t loop=5, i=0,counter=0, aH[6], aHex[6];
   \       0x14   0x2005             MOVS     R0,#+5
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x7108             STRB     R0,[R1, #+4]
   \       0x1A   0x2500             MOVS     R5,#+0
   \       0x1C   0x2400             MOVS     R4,#+0
    547            uint8_t aDec[6], aString[17];
    548            
    549            /* clear the error indicator */
    550            mErrorIndicator = gLCD_NoError_c;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x....             LDR      R1,??DataTable3_2
   \       0x22   0x7008             STRB     R0,[R1, #+0]
    551          
    552           if(numberFormat == gLCD_DecFormat_c) {
   \       0x24   0xA810             ADD      R0,SP,#+64
   \       0x26   0x7800             LDRB     R0,[R0, #+0]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD000             BEQ      .+4
   \       0x2C   0xE0AE             B        ??LCD_WriteStringValue_0
    553              if(value < 100) {
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0x32   0x0C00             LSRS     R0,R0,#+16
   \       0x34   0x2864             CMP      R0,#+100
   \       0x36   0xDA06             BGE      ??LCD_WriteStringValue_1
    554                loop = 2;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x7108             STRB     R0,[R1, #+4]
    555                divDec = 10;
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0x80C8             STRH     R0,[R1, #+6]
   \       0x44   0xE024             B        ??LCD_WriteStringValue_2
    556              }
    557              else if(value >= 100 && value <1000) {
   \                     ??LCD_WriteStringValue_1: (+1)
   \       0x46   0x0038             MOVS     R0,R7
   \       0x48   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0x4A   0x0C00             LSRS     R0,R0,#+16
   \       0x4C   0x2864             CMP      R0,#+100
   \       0x4E   0xDB0D             BLT      ??LCD_WriteStringValue_3
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0x54   0x0C00             LSRS     R0,R0,#+16
   \       0x56   0x21FA             MOVS     R1,#+250
   \       0x58   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x5A   0x4288             CMP      R0,R1
   \       0x5C   0xDA06             BGE      ??LCD_WriteStringValue_3
    558                loop = 3;
   \       0x5E   0x2003             MOVS     R0,#+3
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x7108             STRB     R0,[R1, #+4]
    559                divDec = 100;
   \       0x64   0x2064             MOVS     R0,#+100
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x80C8             STRH     R0,[R1, #+6]
   \       0x6A   0xE011             B        ??LCD_WriteStringValue_2
    560              }
    561              else if(value >= 1000 && value <9999) {
   \                     ??LCD_WriteStringValue_3: (+1)
   \       0x6C   0x20FA             MOVS     R0,#+250
   \       0x6E   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \       0x70   0x0039             MOVS     R1,R7
   \       0x72   0x0409             LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \       0x74   0x0C09             LSRS     R1,R1,#+16
   \       0x76   0x4281             CMP      R1,R0
   \       0x78   0xDB0A             BLT      ??LCD_WriteStringValue_2
   \       0x7A   0x0039             MOVS     R1,R7
   \       0x7C   0x0409             LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \       0x7E   0x0C09             LSRS     R1,R1,#+16
   \       0x80   0x....             LDR      R2,??DataTable3_3  ;; 0x270f
   \       0x82   0x4291             CMP      R1,R2
   \       0x84   0xDA04             BGE      ??LCD_WriteStringValue_2
    562                loop = 4;
   \       0x86   0x2104             MOVS     R1,#+4
   \       0x88   0x466A             MOV      R2,SP
   \       0x8A   0x7111             STRB     R1,[R2, #+4]
    563                divDec = 1000;
   \       0x8C   0x4669             MOV      R1,SP
   \       0x8E   0x80C8             STRH     R0,[R1, #+6]
    564              }
    565          
    566              for(i=0; i<loop; i++) {
   \                     ??LCD_WriteStringValue_2: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x4669             MOV      R1,SP
   \       0x94   0x7008             STRB     R0,[R1, #+0]
   \                     ??LCD_WriteStringValue_4: (+1)
   \       0x96   0x4668             MOV      R0,SP
   \       0x98   0x7800             LDRB     R0,[R0, #+0]
   \       0x9A   0x4669             MOV      R1,SP
   \       0x9C   0x7909             LDRB     R1,[R1, #+4]
   \       0x9E   0x4288             CMP      R0,R1
   \       0xA0   0xD237             BCS      ??LCD_WriteStringValue_5
    567                if((value/divDec)!= 0) {
   \       0xA2   0x0038             MOVS     R0,R7
   \       0xA4   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0xA6   0x0C00             LSRS     R0,R0,#+16
   \       0xA8   0x466A             MOV      R2,SP
   \       0xAA   0x2106             MOVS     R1,#+6
   \       0xAC   0x5E51             LDRSH    R1,[R2, R1]
   \       0xAE   0x....'....        BL       __aeabi_idiv
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD018             BEQ      ??LCD_WriteStringValue_6
    568                  aDec[counter++] = (value/divDec) + 0x30;
   \       0xB6   0x0038             MOVS     R0,R7
   \       0xB8   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0xBA   0x0C00             LSRS     R0,R0,#+16
   \       0xBC   0x466A             MOV      R2,SP
   \       0xBE   0x2106             MOVS     R1,#+6
   \       0xC0   0x5E51             LDRSH    R1,[R2, R1]
   \       0xC2   0x....'....        BL       __aeabi_idiv
   \       0xC6   0x3030             ADDS     R0,R0,#+48
   \       0xC8   0xA903             ADD      R1,SP,#+12
   \       0xCA   0x0022             MOVS     R2,R4
   \       0xCC   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xCE   0x0E12             LSRS     R2,R2,#+24
   \       0xD0   0x5488             STRB     R0,[R1, R2]
   \       0xD2   0x1C64             ADDS     R4,R4,#+1
    569                  value = value % divDec;
   \       0xD4   0x043F             LSLS     R7,R7,#+16       ;; ZeroExtS R7,R7,#+16,#+16
   \       0xD6   0x0C3F             LSRS     R7,R7,#+16
   \       0xD8   0x0038             MOVS     R0,R7
   \       0xDA   0x466A             MOV      R2,SP
   \       0xDC   0x2106             MOVS     R1,#+6
   \       0xDE   0x5E51             LDRSH    R1,[R2, R1]
   \       0xE0   0x....'....        BL       __aeabi_idivmod
   \       0xE4   0x000F             MOVS     R7,R1
   \       0xE6   0xE006             B        ??LCD_WriteStringValue_7
    570                }
    571                else {
    572                  aDec[counter++] = 0x30;
   \                     ??LCD_WriteStringValue_6: (+1)
   \       0xE8   0x2030             MOVS     R0,#+48
   \       0xEA   0xA903             ADD      R1,SP,#+12
   \       0xEC   0x0022             MOVS     R2,R4
   \       0xEE   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xF0   0x0E12             LSRS     R2,R2,#+24
   \       0xF2   0x5488             STRB     R0,[R1, R2]
   \       0xF4   0x1C64             ADDS     R4,R4,#+1
    573                }
    574                divDec = divDec/10;
   \                     ??LCD_WriteStringValue_7: (+1)
   \       0xF6   0x4669             MOV      R1,SP
   \       0xF8   0x2006             MOVS     R0,#+6
   \       0xFA   0x5E08             LDRSH    R0,[R1, R0]
   \       0xFC   0x210A             MOVS     R1,#+10
   \       0xFE   0x....'....        BL       __aeabi_idiv
   \      0x102   0x4669             MOV      R1,SP
   \      0x104   0x80C8             STRH     R0,[R1, #+6]
    575              }
   \      0x106   0x4668             MOV      R0,SP
   \      0x108   0x7800             LDRB     R0,[R0, #+0]
   \      0x10A   0x1C40             ADDS     R0,R0,#+1
   \      0x10C   0x4669             MOV      R1,SP
   \      0x10E   0x7008             STRB     R0,[R1, #+0]
   \      0x110   0xE7C1             B        ??LCD_WriteStringValue_4
    576              aDec[counter]='\0';
   \                     ??LCD_WriteStringValue_5: (+1)
   \      0x112   0xA803             ADD      R0,SP,#+12
   \      0x114   0x2100             MOVS     R1,#+0
   \      0x116   0x0022             MOVS     R2,R4
   \      0x118   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x11A   0x0E12             LSRS     R2,R2,#+24
   \      0x11C   0x5481             STRB     R1,[R0, R2]
    577              counter=0;
   \      0x11E   0x2100             MOVS     R1,#+0
   \      0x120   0x000C             MOVS     R4,R1
    578              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_8: (+1)
   \      0x122   0x7831             LDRB     R1,[R6, #+0]
   \      0x124   0x2900             CMP      R1,#+0
   \      0x126   0xD00D             BEQ      ??LCD_WriteStringValue_9
   \      0x128   0x0021             MOVS     R1,R4
   \      0x12A   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x12C   0x0E09             LSRS     R1,R1,#+24
   \      0x12E   0x2915             CMP      R1,#+21
   \      0x130   0xDA08             BGE      ??LCD_WriteStringValue_9
    579                aString[counter++]=*pstr;
   \      0x132   0x7831             LDRB     R1,[R6, #+0]
   \      0x134   0xAA05             ADD      R2,SP,#+20
   \      0x136   0x0023             MOVS     R3,R4
   \      0x138   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x13A   0x0E1B             LSRS     R3,R3,#+24
   \      0x13C   0x54D1             STRB     R1,[R2, R3]
   \      0x13E   0x1C64             ADDS     R4,R4,#+1
    580                pstr++;
   \      0x140   0x1C76             ADDS     R6,R6,#+1
   \      0x142   0xE7EE             B        ??LCD_WriteStringValue_8
    581              }
    582              i=0;
   \                     ??LCD_WriteStringValue_9: (+1)
   \      0x144   0x2500             MOVS     R5,#+0
    583              while (aDec[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_10: (+1)
   \      0x146   0x0029             MOVS     R1,R5
   \      0x148   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x14A   0x0E09             LSRS     R1,R1,#+24
   \      0x14C   0x5C41             LDRB     R1,[R0, R1]
   \      0x14E   0x2900             CMP      R1,#+0
   \      0x150   0xD010             BEQ      ??LCD_WriteStringValue_11
   \      0x152   0x0021             MOVS     R1,R4
   \      0x154   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x156   0x0E09             LSRS     R1,R1,#+24
   \      0x158   0x2915             CMP      R1,#+21
   \      0x15A   0xDA0B             BGE      ??LCD_WriteStringValue_11
    584                aString[counter++]=aDec[i++];
   \      0x15C   0x0029             MOVS     R1,R5
   \      0x15E   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x160   0x0E09             LSRS     R1,R1,#+24
   \      0x162   0x5C41             LDRB     R1,[R0, R1]
   \      0x164   0xAA05             ADD      R2,SP,#+20
   \      0x166   0x0023             MOVS     R3,R4
   \      0x168   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x16A   0x0E1B             LSRS     R3,R3,#+24
   \      0x16C   0x54D1             STRB     R1,[R2, R3]
   \      0x16E   0x1C6D             ADDS     R5,R5,#+1
   \      0x170   0x1C64             ADDS     R4,R4,#+1
   \      0x172   0xE7E8             B        ??LCD_WriteStringValue_10
    585              }
    586              aString[counter]='\0';
   \                     ??LCD_WriteStringValue_11: (+1)
   \      0x174   0x2000             MOVS     R0,#+0
   \      0x176   0xA905             ADD      R1,SP,#+20
   \      0x178   0x0022             MOVS     R2,R4
   \      0x17A   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x17C   0x0E12             LSRS     R2,R2,#+24
   \      0x17E   0x5488             STRB     R0,[R1, R2]
    587              LCD_WriteString_NormalFont( line, aString );
   \      0x180   0xA905             ADD      R1,SP,#+20
   \      0x182   0xA80F             ADD      R0,SP,#+60
   \      0x184   0x7800             LDRB     R0,[R0, #+0]
   \      0x186   0x....'....        BL       LCD_WriteString_NormalFont
   \      0x18A   0xE088             B        ??LCD_WriteStringValue_12
    588            }
    589            else if(numberFormat == gLCD_HexFormat_c) {
   \                     ??LCD_WriteStringValue_0: (+1)
   \      0x18C   0xA810             ADD      R0,SP,#+64
   \      0x18E   0x7800             LDRB     R0,[R0, #+0]
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD000             BEQ      .+4
   \      0x194   0xE07E             B        ??LCD_WriteStringValue_13
    590              do{
    591                aH[i]=gaHexValue[value % divHex];
   \                     ??LCD_WriteStringValue_14: (+1)
   \      0x196   0x....             LDR      R0,??DataTable3_4
   \      0x198   0x9000             STR      R0,[SP, #+0]
   \      0x19A   0x0038             MOVS     R0,R7
   \      0x19C   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \      0x19E   0x0C00             LSRS     R0,R0,#+16
   \      0x1A0   0x466A             MOV      R2,SP
   \      0x1A2   0x2108             MOVS     R1,#+8
   \      0x1A4   0x5E51             LDRSH    R1,[R2, R1]
   \      0x1A6   0x....'....        BL       __aeabi_idivmod
   \      0x1AA   0x9800             LDR      R0,[SP, #+0]
   \      0x1AC   0x5C40             LDRB     R0,[R0, R1]
   \      0x1AE   0xA90C             ADD      R1,SP,#+48
   \      0x1B0   0x002A             MOVS     R2,R5
   \      0x1B2   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1B4   0x0E12             LSRS     R2,R2,#+24
   \      0x1B6   0x5488             STRB     R0,[R1, R2]
    592                value=value / divHex;
   \      0x1B8   0x043F             LSLS     R7,R7,#+16       ;; ZeroExtS R7,R7,#+16,#+16
   \      0x1BA   0x0C3F             LSRS     R7,R7,#+16
   \      0x1BC   0x0038             MOVS     R0,R7
   \      0x1BE   0x466A             MOV      R2,SP
   \      0x1C0   0x2108             MOVS     R1,#+8
   \      0x1C2   0x5E51             LDRSH    R1,[R2, R1]
   \      0x1C4   0x....'....        BL       __aeabi_idiv
   \      0x1C8   0x0007             MOVS     R7,R0
    593                i++;
   \      0x1CA   0x1C6D             ADDS     R5,R5,#+1
    594              }
    595              while(value > 15);
   \      0x1CC   0x0038             MOVS     R0,R7
   \      0x1CE   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \      0x1D0   0x0C00             LSRS     R0,R0,#+16
   \      0x1D2   0x2810             CMP      R0,#+16
   \      0x1D4   0xDADF             BGE      ??LCD_WriteStringValue_14
    596              aH[i]=gaHexValue[value];
   \      0x1D6   0xA90C             ADD      R1,SP,#+48
   \      0x1D8   0x....             LDR      R0,??DataTable3_4
   \      0x1DA   0x003A             MOVS     R2,R7
   \      0x1DC   0x0412             LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \      0x1DE   0x0C12             LSRS     R2,R2,#+16
   \      0x1E0   0x5C80             LDRB     R0,[R0, R2]
   \      0x1E2   0x002A             MOVS     R2,R5
   \      0x1E4   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1E6   0x0E12             LSRS     R2,R2,#+24
   \      0x1E8   0x5488             STRB     R0,[R1, R2]
    597              counter=0;
   \      0x1EA   0x2000             MOVS     R0,#+0
    598              while(i > 0){
   \                     ??LCD_WriteStringValue_15: (+1)
   \      0x1EC   0x002A             MOVS     R2,R5
   \      0x1EE   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1F0   0x0E12             LSRS     R2,R2,#+24
   \      0x1F2   0x2A00             CMP      R2,#+0
   \      0x1F4   0xD00B             BEQ      ??LCD_WriteStringValue_16
    599                aHex[counter++]=aH[i--];
   \      0x1F6   0x002A             MOVS     R2,R5
   \      0x1F8   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1FA   0x0E12             LSRS     R2,R2,#+24
   \      0x1FC   0x5C8A             LDRB     R2,[R1, R2]
   \      0x1FE   0xAB0A             ADD      R3,SP,#+40
   \      0x200   0x0004             MOVS     R4,R0
   \      0x202   0x0624             LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \      0x204   0x0E24             LSRS     R4,R4,#+24
   \      0x206   0x551A             STRB     R2,[R3, R4]
   \      0x208   0x1E6D             SUBS     R5,R5,#+1
   \      0x20A   0x1C40             ADDS     R0,R0,#+1
   \      0x20C   0xE7EE             B        ??LCD_WriteStringValue_15
    600              }
    601          
    602              aHex[counter++]=aH[0];
   \                     ??LCD_WriteStringValue_16: (+1)
   \      0x20E   0xAA0A             ADD      R2,SP,#+40
   \      0x210   0x7809             LDRB     R1,[R1, #+0]
   \      0x212   0x0003             MOVS     R3,R0
   \      0x214   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x216   0x0E1B             LSRS     R3,R3,#+24
   \      0x218   0x54D1             STRB     R1,[R2, R3]
   \      0x21A   0x1C40             ADDS     R0,R0,#+1
    603              aHex[counter]='\0';
   \      0x21C   0x2100             MOVS     R1,#+0
   \      0x21E   0x0003             MOVS     R3,R0
   \      0x220   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x222   0x0E1B             LSRS     R3,R3,#+24
   \      0x224   0x54D1             STRB     R1,[R2, R3]
    604          
    605              counter=0;
   \      0x226   0x2400             MOVS     R4,#+0
    606              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_17: (+1)
   \      0x228   0x7830             LDRB     R0,[R6, #+0]
   \      0x22A   0x2800             CMP      R0,#+0
   \      0x22C   0xD00D             BEQ      ??LCD_WriteStringValue_18
   \      0x22E   0x0020             MOVS     R0,R4
   \      0x230   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x232   0x0E00             LSRS     R0,R0,#+24
   \      0x234   0x2815             CMP      R0,#+21
   \      0x236   0xDA08             BGE      ??LCD_WriteStringValue_18
    607                aString[counter++]=*pstr;
   \      0x238   0x7830             LDRB     R0,[R6, #+0]
   \      0x23A   0xA905             ADD      R1,SP,#+20
   \      0x23C   0x0023             MOVS     R3,R4
   \      0x23E   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x240   0x0E1B             LSRS     R3,R3,#+24
   \      0x242   0x54C8             STRB     R0,[R1, R3]
   \      0x244   0x1C64             ADDS     R4,R4,#+1
    608                pstr++;
   \      0x246   0x1C76             ADDS     R6,R6,#+1
   \      0x248   0xE7EE             B        ??LCD_WriteStringValue_17
    609              }
    610              i=0;
   \                     ??LCD_WriteStringValue_18: (+1)
   \      0x24A   0x2000             MOVS     R0,#+0
   \      0x24C   0x0005             MOVS     R5,R0
    611              while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_19: (+1)
   \      0x24E   0x0028             MOVS     R0,R5
   \      0x250   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x252   0x0E00             LSRS     R0,R0,#+24
   \      0x254   0x5C10             LDRB     R0,[R2, R0]
   \      0x256   0x2800             CMP      R0,#+0
   \      0x258   0xD010             BEQ      ??LCD_WriteStringValue_20
   \      0x25A   0x0020             MOVS     R0,R4
   \      0x25C   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x25E   0x0E00             LSRS     R0,R0,#+24
   \      0x260   0x2815             CMP      R0,#+21
   \      0x262   0xDA0B             BGE      ??LCD_WriteStringValue_20
    612                aString[counter++]=aHex[i++];
   \      0x264   0x0028             MOVS     R0,R5
   \      0x266   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x268   0x0E00             LSRS     R0,R0,#+24
   \      0x26A   0x5C10             LDRB     R0,[R2, R0]
   \      0x26C   0xA905             ADD      R1,SP,#+20
   \      0x26E   0x0023             MOVS     R3,R4
   \      0x270   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x272   0x0E1B             LSRS     R3,R3,#+24
   \      0x274   0x54C8             STRB     R0,[R1, R3]
   \      0x276   0x1C6D             ADDS     R5,R5,#+1
   \      0x278   0x1C64             ADDS     R4,R4,#+1
   \      0x27A   0xE7E8             B        ??LCD_WriteStringValue_19
    613              }
    614              aString[counter]='\0';
   \                     ??LCD_WriteStringValue_20: (+1)
   \      0x27C   0x2000             MOVS     R0,#+0
   \      0x27E   0xA905             ADD      R1,SP,#+20
   \      0x280   0x0022             MOVS     R2,R4
   \      0x282   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x284   0x0E12             LSRS     R2,R2,#+24
   \      0x286   0x5488             STRB     R0,[R1, R2]
    615              LCD_WriteString_NormalFont( line, aString );
   \      0x288   0xA905             ADD      R1,SP,#+20
   \      0x28A   0xA80F             ADD      R0,SP,#+60
   \      0x28C   0x7800             LDRB     R0,[R0, #+0]
   \      0x28E   0x....'....        BL       LCD_WriteString_NormalFont
   \      0x292   0xE004             B        ??LCD_WriteStringValue_12
    616            }
    617            else {
    618              LCD_WriteString_NormalFont( line, "Format unknow" );
   \                     ??LCD_WriteStringValue_13: (+1)
   \      0x294   0x....             LDR      R1,??DataTable4
   \      0x296   0xA80F             ADD      R0,SP,#+60
   \      0x298   0x7800             LDRB     R0,[R0, #+0]
   \      0x29A   0x....'....        BL       LCD_WriteString_NormalFont
    619            }
    620          }
   \                     ??LCD_WriteStringValue_12: (+1)
   \      0x29E   0xB011             ADD      SP,SP,#+68
   \      0x2A0   0xBCF0             POP      {R4-R7}
   \      0x2A2   0xBC08             POP      {R3}
   \      0x2A4   0x4718             BX       R3               ;; return
    621          

   \                                 In section .text, align 2, keep-with-next
    622          void LCD_WriteStringDecValue
    623            (
    624            uint8_t *pstr,     /* IN: Pointer to text string */
    625            uint16_t value,    /* IN: Value */
    626            uint8_t line, 	   /* IN: Line in display */
    627            LCD_t numberFormat /* IN: Value to show in HEX or DEC */
    628            )
    629          {
   \                     LCD_WriteStringDecValue: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB08E             SUB      SP,SP,#+56
   \        0x4   0x0007             MOVS     R7,R0
    630          
    631            int16_t divDec=10000, divHex=16;
   \        0x6   0x....             LDR      R6,??DataTable4_1  ;; 0x2710
   \        0x8   0x2010             MOVS     R0,#+16
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x8108             STRH     R0,[R1, #+8]
    632            uint8_t loop=5, i=0,counter=0, aH[6], aHex[6];
   \        0xE   0x2005             MOVS     R0,#+5
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x7188             STRB     R0,[R1, #+6]
   \       0x14   0x2500             MOVS     R5,#+0
   \       0x16   0x2400             MOVS     R4,#+0
    633            uint8_t aDec[6], aString[17] = {0};
   \       0x18   0xA805             ADD      R0,SP,#+20
   \       0x1A   0x2114             MOVS     R1,#+20
   \       0x1C   0x....'....        BL       __aeabi_memclr4
    634            uint8_t u8TempVal;
    635            uint8_t u8Count;
    636           
    637            
    638            /* clear the error indicator */
    639            mErrorIndicator = gLCD_NoError_c;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....             LDR      R1,??DataTable4_2
   \       0x24   0x7008             STRB     R0,[R1, #+0]
    640          
    641           if(numberFormat == gLCD_DecFormat_c) {
   \       0x26   0xA810             ADD      R0,SP,#+64
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD000             BEQ      .+4
   \       0x2E   0xE0AC             B        ??LCD_WriteStringDecValue_0
    642              u8TempVal = (value >> 8);
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x8F00             LDRH     R0,[R0, #+56]
   \       0x34   0x0400             LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \       0x36   0x0C00             LSRS     R0,R0,#+16
   \       0x38   0x0A00             LSRS     R0,R0,#+8
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x7108             STRB     R0,[R1, #+4]
    643              
    644              for( u8Count= 0;  u8Count < 2;  u8Count++)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0x7148             STRB     R0,[R1, #+5]
   \                     ??LCD_WriteStringDecValue_1: (+1)
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x7940             LDRB     R0,[R0, #+5]
   \       0x48   0x2802             CMP      R0,#+2
   \       0x4A   0xDA65             BGE      ??LCD_WriteStringDecValue_2
    645              {
    646                if(u8TempVal < 100) 
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x7900             LDRB     R0,[R0, #+4]
   \       0x50   0x2864             CMP      R0,#+100
   \       0x52   0xDA05             BGE      ??LCD_WriteStringDecValue_3
    647                {
    648                  loop = 2;
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0x4669             MOV      R1,SP
   \       0x58   0x7188             STRB     R0,[R1, #+6]
    649                  divDec = 10;
   \       0x5A   0x200A             MOVS     R0,#+10
   \       0x5C   0x0006             MOVS     R6,R0
   \       0x5E   0xE00C             B        ??LCD_WriteStringDecValue_4
    650                }
    651                else if(u8TempVal >= 100 && u8TempVal < 255) {
   \                     ??LCD_WriteStringDecValue_3: (+1)
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x7900             LDRB     R0,[R0, #+4]
   \       0x64   0x2864             CMP      R0,#+100
   \       0x66   0xDB08             BLT      ??LCD_WriteStringDecValue_4
   \       0x68   0x4668             MOV      R0,SP
   \       0x6A   0x7900             LDRB     R0,[R0, #+4]
   \       0x6C   0x28FF             CMP      R0,#+255
   \       0x6E   0xD004             BEQ      ??LCD_WriteStringDecValue_4
    652                  loop = 3;
   \       0x70   0x2003             MOVS     R0,#+3
   \       0x72   0x4669             MOV      R1,SP
   \       0x74   0x7188             STRB     R0,[R1, #+6]
    653                  divDec = 100;
   \       0x76   0x2064             MOVS     R0,#+100
   \       0x78   0x0006             MOVS     R6,R0
    654                }
    655                for(i=0; i<loop; i++) {
   \                     ??LCD_WriteStringDecValue_4: (+1)
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x0005             MOVS     R5,R0
   \                     ??LCD_WriteStringDecValue_5: (+1)
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x4669             MOV      R1,SP
   \       0x82   0x7989             LDRB     R1,[R1, #+6]
   \       0x84   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x86   0x0E00             LSRS     R0,R0,#+24
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD230             BCS      ??LCD_WriteStringDecValue_6
    656                  if((u8TempVal/divDec)!= 0) 
   \       0x8C   0x4668             MOV      R0,SP
   \       0x8E   0x7900             LDRB     R0,[R0, #+4]
   \       0x90   0x0031             MOVS     R1,R6
   \       0x92   0x0409             LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \       0x94   0x1409             ASRS     R1,R1,#+16
   \       0x96   0x....'....        BL       __aeabi_idiv
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD017             BEQ      ??LCD_WriteStringDecValue_7
    657                  {
    658                    aDec[counter++] = (u8TempVal/divDec) + 0x30;
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x7900             LDRB     R0,[R0, #+4]
   \       0xA2   0x0031             MOVS     R1,R6
   \       0xA4   0x0409             LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \       0xA6   0x1409             ASRS     R1,R1,#+16
   \       0xA8   0x....'....        BL       __aeabi_idiv
   \       0xAC   0x3030             ADDS     R0,R0,#+48
   \       0xAE   0xA903             ADD      R1,SP,#+12
   \       0xB0   0x0022             MOVS     R2,R4
   \       0xB2   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xB4   0x0E12             LSRS     R2,R2,#+24
   \       0xB6   0x5488             STRB     R0,[R1, R2]
   \       0xB8   0x1C64             ADDS     R4,R4,#+1
    659                    u8TempVal = u8TempVal % divDec;
   \       0xBA   0x4668             MOV      R0,SP
   \       0xBC   0x7900             LDRB     R0,[R0, #+4]
   \       0xBE   0x0031             MOVS     R1,R6
   \       0xC0   0x0409             LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \       0xC2   0x1409             ASRS     R1,R1,#+16
   \       0xC4   0x....'....        BL       __aeabi_idivmod
   \       0xC8   0x4668             MOV      R0,SP
   \       0xCA   0x7101             STRB     R1,[R0, #+4]
   \       0xCC   0xE006             B        ??LCD_WriteStringDecValue_8
    660                  }
    661                  else {
    662                    aDec[counter++] = 0x30;
   \                     ??LCD_WriteStringDecValue_7: (+1)
   \       0xCE   0x2030             MOVS     R0,#+48
   \       0xD0   0xA903             ADD      R1,SP,#+12
   \       0xD2   0x0022             MOVS     R2,R4
   \       0xD4   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xD6   0x0E12             LSRS     R2,R2,#+24
   \       0xD8   0x5488             STRB     R0,[R1, R2]
   \       0xDA   0x1C64             ADDS     R4,R4,#+1
    663                  }
    664                  divDec = divDec/10;
   \                     ??LCD_WriteStringDecValue_8: (+1)
   \       0xDC   0x0436             LSLS     R6,R6,#+16       ;; SignExtS R6,R6,#+16,#+16
   \       0xDE   0x1436             ASRS     R6,R6,#+16
   \       0xE0   0x0030             MOVS     R0,R6
   \       0xE2   0x210A             MOVS     R1,#+10
   \       0xE4   0x....'....        BL       __aeabi_idiv
   \       0xE8   0x0006             MOVS     R6,R0
    665                }
   \       0xEA   0x1C6D             ADDS     R5,R5,#+1
   \       0xEC   0xE7C7             B        ??LCD_WriteStringDecValue_5
    666                if(u8Count < 1)
   \                     ??LCD_WriteStringDecValue_6: (+1)
   \       0xEE   0x4668             MOV      R0,SP
   \       0xF0   0x7940             LDRB     R0,[R0, #+5]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD106             BNE      ??LCD_WriteStringDecValue_9
    667                {  
    668                  aDec[counter++] = '.';
   \       0xF6   0x202E             MOVS     R0,#+46
   \       0xF8   0xA903             ADD      R1,SP,#+12
   \       0xFA   0x0022             MOVS     R2,R4
   \       0xFC   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xFE   0x0E12             LSRS     R2,R2,#+24
   \      0x100   0x5488             STRB     R0,[R1, R2]
   \      0x102   0x1C64             ADDS     R4,R4,#+1
    669                }
    670                u8TempVal = value;
   \                     ??LCD_WriteStringDecValue_9: (+1)
   \      0x104   0x4668             MOV      R0,SP
   \      0x106   0x8F00             LDRH     R0,[R0, #+56]
   \      0x108   0x4669             MOV      R1,SP
   \      0x10A   0x7108             STRB     R0,[R1, #+4]
    671              } 
   \      0x10C   0x4668             MOV      R0,SP
   \      0x10E   0x7940             LDRB     R0,[R0, #+5]
   \      0x110   0x1C40             ADDS     R0,R0,#+1
   \      0x112   0x4669             MOV      R1,SP
   \      0x114   0x7148             STRB     R0,[R1, #+5]
   \      0x116   0xE795             B        ??LCD_WriteStringDecValue_1
    672                
    673              aDec[counter]='\0';
   \                     ??LCD_WriteStringDecValue_2: (+1)
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0x0001             MOVS     R1,R0
   \      0x11C   0xAA03             ADD      R2,SP,#+12
   \      0x11E   0x0023             MOVS     R3,R4
   \      0x120   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x122   0x0E1B             LSRS     R3,R3,#+24
   \      0x124   0x54D1             STRB     R1,[R2, R3]
    674              counter=0;
   \      0x126   0x0001             MOVS     R1,R0
   \      0x128   0x000C             MOVS     R4,R1
    675              
    676              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) 
   \                     ??LCD_WriteStringDecValue_10: (+1)
   \      0x12A   0x7839             LDRB     R1,[R7, #+0]
   \      0x12C   0x2900             CMP      R1,#+0
   \      0x12E   0xD00D             BEQ      ??LCD_WriteStringDecValue_11
   \      0x130   0x0021             MOVS     R1,R4
   \      0x132   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x134   0x0E09             LSRS     R1,R1,#+24
   \      0x136   0x2915             CMP      R1,#+21
   \      0x138   0xDA08             BGE      ??LCD_WriteStringDecValue_11
    677              {
    678                aString[counter++]=*pstr;
   \      0x13A   0x7839             LDRB     R1,[R7, #+0]
   \      0x13C   0xAA05             ADD      R2,SP,#+20
   \      0x13E   0x0023             MOVS     R3,R4
   \      0x140   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x142   0x0E1B             LSRS     R3,R3,#+24
   \      0x144   0x54D1             STRB     R1,[R2, R3]
   \      0x146   0x1C64             ADDS     R4,R4,#+1
    679                pstr++;
   \      0x148   0x1C7F             ADDS     R7,R7,#+1
   \      0x14A   0xE7EE             B        ??LCD_WriteStringDecValue_10
    680              }
    681              i=0;
   \                     ??LCD_WriteStringDecValue_11: (+1)
   \      0x14C   0x0005             MOVS     R5,R0
    682          
    683              while (aDec[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringDecValue_12: (+1)
   \      0x14E   0xA803             ADD      R0,SP,#+12
   \      0x150   0x0029             MOVS     R1,R5
   \      0x152   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x154   0x0E09             LSRS     R1,R1,#+24
   \      0x156   0x5C41             LDRB     R1,[R0, R1]
   \      0x158   0x2900             CMP      R1,#+0
   \      0x15A   0xD010             BEQ      ??LCD_WriteStringDecValue_13
   \      0x15C   0x0021             MOVS     R1,R4
   \      0x15E   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x160   0x0E09             LSRS     R1,R1,#+24
   \      0x162   0x2915             CMP      R1,#+21
   \      0x164   0xDA0B             BGE      ??LCD_WriteStringDecValue_13
    684                aString[counter++]=aDec[i++];
   \      0x166   0x0029             MOVS     R1,R5
   \      0x168   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \      0x16A   0x0E09             LSRS     R1,R1,#+24
   \      0x16C   0x5C40             LDRB     R0,[R0, R1]
   \      0x16E   0xA905             ADD      R1,SP,#+20
   \      0x170   0x0022             MOVS     R2,R4
   \      0x172   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x174   0x0E12             LSRS     R2,R2,#+24
   \      0x176   0x5488             STRB     R0,[R1, R2]
   \      0x178   0x1C6D             ADDS     R5,R5,#+1
   \      0x17A   0x1C64             ADDS     R4,R4,#+1
   \      0x17C   0xE7E7             B        ??LCD_WriteStringDecValue_12
    685              }
    686              LCD_WriteString_NormalFont( line, aString );
   \                     ??LCD_WriteStringDecValue_13: (+1)
   \      0x17E   0xA905             ADD      R1,SP,#+20
   \      0x180   0xA80F             ADD      R0,SP,#+60
   \      0x182   0x7800             LDRB     R0,[R0, #+0]
   \      0x184   0x....'....        BL       LCD_WriteString_NormalFont
   \      0x188   0xE084             B        ??LCD_WriteStringDecValue_14
    687            }
    688           
    689            else if(numberFormat == gLCD_HexFormat_c) {
   \                     ??LCD_WriteStringDecValue_0: (+1)
   \      0x18A   0xA810             ADD      R0,SP,#+64
   \      0x18C   0x7800             LDRB     R0,[R0, #+0]
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD17B             BNE      ??LCD_WriteStringDecValue_15
    690              do{
    691                aH[i]=gaHexValue[value % divHex];
   \                     ??LCD_WriteStringDecValue_16: (+1)
   \      0x192   0x....             LDR      R0,??DataTable9
   \      0x194   0x9000             STR      R0,[SP, #+0]
   \      0x196   0x4668             MOV      R0,SP
   \      0x198   0x8F00             LDRH     R0,[R0, #+56]
   \      0x19A   0x466A             MOV      R2,SP
   \      0x19C   0x2108             MOVS     R1,#+8
   \      0x19E   0x5E51             LDRSH    R1,[R2, R1]
   \      0x1A0   0x....'....        BL       __aeabi_idivmod
   \      0x1A4   0x9800             LDR      R0,[SP, #+0]
   \      0x1A6   0x5C40             LDRB     R0,[R0, R1]
   \      0x1A8   0xA90C             ADD      R1,SP,#+48
   \      0x1AA   0x002A             MOVS     R2,R5
   \      0x1AC   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1AE   0x0E12             LSRS     R2,R2,#+24
   \      0x1B0   0x5488             STRB     R0,[R1, R2]
    692                value=value / divHex;
   \      0x1B2   0x4668             MOV      R0,SP
   \      0x1B4   0x8F00             LDRH     R0,[R0, #+56]
   \      0x1B6   0x466A             MOV      R2,SP
   \      0x1B8   0x2108             MOVS     R1,#+8
   \      0x1BA   0x5E51             LDRSH    R1,[R2, R1]
   \      0x1BC   0x....'....        BL       __aeabi_idiv
   \      0x1C0   0x4669             MOV      R1,SP
   \      0x1C2   0x8708             STRH     R0,[R1, #+56]
    693                i++;
   \      0x1C4   0x1C6D             ADDS     R5,R5,#+1
    694              }
    695              while(value > 15);
   \      0x1C6   0x4668             MOV      R0,SP
   \      0x1C8   0x8F00             LDRH     R0,[R0, #+56]
   \      0x1CA   0x2810             CMP      R0,#+16
   \      0x1CC   0xDAE1             BGE      ??LCD_WriteStringDecValue_16
    696              aH[i]=gaHexValue[value];
   \      0x1CE   0xA90C             ADD      R1,SP,#+48
   \      0x1D0   0x....             LDR      R0,??DataTable9
   \      0x1D2   0x466A             MOV      R2,SP
   \      0x1D4   0x8F12             LDRH     R2,[R2, #+56]
   \      0x1D6   0x5C80             LDRB     R0,[R0, R2]
   \      0x1D8   0x002A             MOVS     R2,R5
   \      0x1DA   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1DC   0x0E12             LSRS     R2,R2,#+24
   \      0x1DE   0x5488             STRB     R0,[R1, R2]
    697              counter=0;
   \      0x1E0   0x2000             MOVS     R0,#+0
    698              while(i > 0){
   \                     ??LCD_WriteStringDecValue_17: (+1)
   \      0x1E2   0x002A             MOVS     R2,R5
   \      0x1E4   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1E6   0x0E12             LSRS     R2,R2,#+24
   \      0x1E8   0x2A00             CMP      R2,#+0
   \      0x1EA   0xD00B             BEQ      ??LCD_WriteStringDecValue_18
    699                aHex[counter++]=aH[i--];
   \      0x1EC   0x002A             MOVS     R2,R5
   \      0x1EE   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x1F0   0x0E12             LSRS     R2,R2,#+24
   \      0x1F2   0x5C8A             LDRB     R2,[R1, R2]
   \      0x1F4   0xAB0A             ADD      R3,SP,#+40
   \      0x1F6   0x0004             MOVS     R4,R0
   \      0x1F8   0x0624             LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \      0x1FA   0x0E24             LSRS     R4,R4,#+24
   \      0x1FC   0x551A             STRB     R2,[R3, R4]
   \      0x1FE   0x1E6D             SUBS     R5,R5,#+1
   \      0x200   0x1C40             ADDS     R0,R0,#+1
   \      0x202   0xE7EE             B        ??LCD_WriteStringDecValue_17
    700              }
    701          
    702              aHex[counter++]=aH[0];
   \                     ??LCD_WriteStringDecValue_18: (+1)
   \      0x204   0xAA0A             ADD      R2,SP,#+40
   \      0x206   0x7809             LDRB     R1,[R1, #+0]
   \      0x208   0x0003             MOVS     R3,R0
   \      0x20A   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x20C   0x0E1B             LSRS     R3,R3,#+24
   \      0x20E   0x54D1             STRB     R1,[R2, R3]
   \      0x210   0x1C40             ADDS     R0,R0,#+1
    703              aHex[counter]='\0';
   \      0x212   0x2100             MOVS     R1,#+0
   \      0x214   0x0003             MOVS     R3,R0
   \      0x216   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x218   0x0E1B             LSRS     R3,R3,#+24
   \      0x21A   0x54D1             STRB     R1,[R2, R3]
    704          
    705              counter=0;
   \      0x21C   0x2400             MOVS     R4,#+0
    706              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringDecValue_19: (+1)
   \      0x21E   0x7838             LDRB     R0,[R7, #+0]
   \      0x220   0x2800             CMP      R0,#+0
   \      0x222   0xD00D             BEQ      ??LCD_WriteStringDecValue_20
   \      0x224   0x0020             MOVS     R0,R4
   \      0x226   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x228   0x0E00             LSRS     R0,R0,#+24
   \      0x22A   0x2815             CMP      R0,#+21
   \      0x22C   0xDA08             BGE      ??LCD_WriteStringDecValue_20
    707                aString[counter++]=*pstr;
   \      0x22E   0x7838             LDRB     R0,[R7, #+0]
   \      0x230   0xA905             ADD      R1,SP,#+20
   \      0x232   0x0023             MOVS     R3,R4
   \      0x234   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x236   0x0E1B             LSRS     R3,R3,#+24
   \      0x238   0x54C8             STRB     R0,[R1, R3]
   \      0x23A   0x1C64             ADDS     R4,R4,#+1
    708                pstr++;
   \      0x23C   0x1C7F             ADDS     R7,R7,#+1
   \      0x23E   0xE7EE             B        ??LCD_WriteStringDecValue_19
    709              }
    710              i=0;
   \                     ??LCD_WriteStringDecValue_20: (+1)
   \      0x240   0x2000             MOVS     R0,#+0
   \      0x242   0x0005             MOVS     R5,R0
    711              while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringDecValue_21: (+1)
   \      0x244   0x0028             MOVS     R0,R5
   \      0x246   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x248   0x0E00             LSRS     R0,R0,#+24
   \      0x24A   0x5C10             LDRB     R0,[R2, R0]
   \      0x24C   0x2800             CMP      R0,#+0
   \      0x24E   0xD010             BEQ      ??LCD_WriteStringDecValue_22
   \      0x250   0x0020             MOVS     R0,R4
   \      0x252   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x254   0x0E00             LSRS     R0,R0,#+24
   \      0x256   0x2815             CMP      R0,#+21
   \      0x258   0xDA0B             BGE      ??LCD_WriteStringDecValue_22
    712                aString[counter++]=aHex[i++];
   \      0x25A   0x0028             MOVS     R0,R5
   \      0x25C   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \      0x25E   0x0E00             LSRS     R0,R0,#+24
   \      0x260   0x5C10             LDRB     R0,[R2, R0]
   \      0x262   0xA905             ADD      R1,SP,#+20
   \      0x264   0x0023             MOVS     R3,R4
   \      0x266   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x268   0x0E1B             LSRS     R3,R3,#+24
   \      0x26A   0x54C8             STRB     R0,[R1, R3]
   \      0x26C   0x1C6D             ADDS     R5,R5,#+1
   \      0x26E   0x1C64             ADDS     R4,R4,#+1
   \      0x270   0xE7E8             B        ??LCD_WriteStringDecValue_21
    713              }
    714              aString[counter]='\0';
   \                     ??LCD_WriteStringDecValue_22: (+1)
   \      0x272   0x2000             MOVS     R0,#+0
   \      0x274   0xA905             ADD      R1,SP,#+20
   \      0x276   0x0022             MOVS     R2,R4
   \      0x278   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x27A   0x0E12             LSRS     R2,R2,#+24
   \      0x27C   0x5488             STRB     R0,[R1, R2]
    715              LCD_WriteString_NormalFont( line, aString );
   \      0x27E   0xA905             ADD      R1,SP,#+20
   \      0x280   0xA80F             ADD      R0,SP,#+60
   \      0x282   0x7800             LDRB     R0,[R0, #+0]
   \      0x284   0x....'....        BL       LCD_WriteString_NormalFont
   \      0x288   0xE004             B        ??LCD_WriteStringDecValue_14
    716            }
    717            else {
    718              LCD_WriteString_NormalFont( line,"Format unknow"); 
   \                     ??LCD_WriteStringDecValue_15: (+1)
   \      0x28A   0x....             LDR      R1,??DataTable4
   \      0x28C   0xA80F             ADD      R0,SP,#+60
   \      0x28E   0x7800             LDRB     R0,[R0, #+0]
   \      0x290   0x....'....        BL       LCD_WriteString_NormalFont
    719            }
    720          }
   \                     ??LCD_WriteStringDecValue_14: (+1)
   \      0x294   0xB011             ADD      SP,SP,#+68
   \      0x296   0xBCF0             POP      {R4-R7}
   \      0x298   0xBC08             POP      {R3}
   \      0x29A   0x4718             BX       R3               ;; return
    721          
    722          
    723          
    724          /******************************************************************************
    725          * This functions allows to write raw bytes to the LCD, the maximum number of bytes
    726          *	capable per line is 8, this functions transfors every hex simbol in a byte to a char.
    727          *
    728          * Interface assumptions:
    729          *	IN: The pointer to the label to print with the bytes.
    730          *	IN: The bytes to print.
    731          *	IN: The line in the LCD where the bytes with the label.
    732          *	IN: The number of bytes to print in the LCD.
    733          *
    734          * Return value:
    735          * None
    736          *
    737          *
    738          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    739          void LCD_WriteBytes
    740          (
    741          	uint8_t   *pstr,   /* IN: The pointer to the label to print with the bytes. */
    742          	uint8_t   *value,  /* IN: The bytes to print in hex. */
    743          	uint8_t   line,    /* IN: The line in the LCD where the bytes with the label. */
    744          	uint8_t   length   /* IN: The number of bytes to print in the LCD. */
    745          )
    746          {
   \                     LCD_WriteBytes: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
   \        0x4   0x0006             MOVS     R6,R0
    747          
    748          	uint8_t i=0,counter=0, cIndex,auxIndex;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7088             STRB     R0,[R1, #+2]
   \        0xC   0x2500             MOVS     R5,#+0
    749          	uint8_t aString[17];
    750          
    751          	uint8_t  hexIndex;
    752          	uint8_t aHex[gMAX_LCD_CHARS_c]={'S','i','z','e',' ','N','o','t',' ','V','a','l','i','d','*','*'};
   \        0xE   0xA806             ADD      R0,SP,#+24
   \       0x10   0x....             LDR      R1,??DataTable9_1
   \       0x12   0x2218             MOVS     R2,#+24
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    753          
    754            /* clear the error indicator */
    755            mErrorIndicator = gLCD_NoError_c;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....             LDR      R1,??DataTable9_2
   \       0x1C   0x7008             STRB     R0,[R1, #+0]
    756            
    757          	counter=0;
   \       0x1E   0x2400             MOVS     R4,#+0
    758          	while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c )
   \                     ??LCD_WriteBytes_0: (+1)
   \       0x20   0x7830             LDRB     R0,[R6, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00D             BEQ      ??LCD_WriteBytes_1
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x2A   0x0E00             LSRS     R0,R0,#+24
   \       0x2C   0x2815             CMP      R0,#+21
   \       0x2E   0xDA08             BGE      ??LCD_WriteBytes_1
    759          	{
    760          		aString[counter++]=*pstr;
   \       0x30   0x7830             LDRB     R0,[R6, #+0]
   \       0x32   0xA901             ADD      R1,SP,#+4
   \       0x34   0x0022             MOVS     R2,R4
   \       0x36   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x38   0x0E12             LSRS     R2,R2,#+24
   \       0x3A   0x5488             STRB     R0,[R1, R2]
   \       0x3C   0x1C64             ADDS     R4,R4,#+1
    761          		pstr++;
   \       0x3E   0x1C76             ADDS     R6,R6,#+1
   \       0x40   0xE7EE             B        ??LCD_WriteBytes_0
    762          	}
    763          	if ((((length*2)+counter) <= gMAX_LCD_CHARS_c) && ((length*2) > 0))
   \                     ??LCD_WriteBytes_1: (+1)
   \       0x42   0xA80E             ADD      R0,SP,#+56
   \       0x44   0x7800             LDRB     R0,[R0, #+0]
   \       0x46   0x2102             MOVS     R1,#+2
   \       0x48   0x4348             MULS     R0,R1,R0
   \       0x4A   0x0021             MOVS     R1,R4
   \       0x4C   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x4E   0x0E09             LSRS     R1,R1,#+24
   \       0x50   0x1840             ADDS     R0,R0,R1
   \       0x52   0x2816             CMP      R0,#+22
   \       0x54   0xDA44             BGE      ??LCD_WriteBytes_2
   \       0x56   0xA80E             ADD      R0,SP,#+56
   \       0x58   0x7800             LDRB     R0,[R0, #+0]
   \       0x5A   0x2102             MOVS     R1,#+2
   \       0x5C   0x4348             MULS     R0,R1,R0
   \       0x5E   0x2801             CMP      R0,#+1
   \       0x60   0xDB3E             BLT      ??LCD_WriteBytes_2
    764          	{
    765          		for (cIndex =0,auxIndex = 0; cIndex < length; cIndex++,auxIndex+=2)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0x000F             MOVS     R7,R1
   \       0x68   0x0001             MOVS     R1,R0
   \       0x6A   0x466A             MOV      R2,SP
   \       0x6C   0x7011             STRB     R1,[R2, #+0]
   \                     ??LCD_WriteBytes_3: (+1)
   \       0x6E   0x0039             MOVS     R1,R7
   \       0x70   0xAA0E             ADD      R2,SP,#+56
   \       0x72   0x7812             LDRB     R2,[R2, #+0]
   \       0x74   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x76   0x0E09             LSRS     R1,R1,#+24
   \       0x78   0x4291             CMP      R1,R2
   \       0x7A   0xD22A             BCS      ??LCD_WriteBytes_4
    766          		{
    767          			hexIndex = value[cIndex]&0xf0;
   \       0x7C   0x990C             LDR      R1,[SP, #+48]
   \       0x7E   0x003A             MOVS     R2,R7
   \       0x80   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x82   0x0E12             LSRS     R2,R2,#+24
   \       0x84   0x5C8A             LDRB     R2,[R1, R2]
   \       0x86   0x21F0             MOVS     R1,#+240
   \       0x88   0x4011             ANDS     R1,R1,R2
    768          			hexIndex = hexIndex>>4;
   \       0x8A   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x8C   0x0E09             LSRS     R1,R1,#+24
   \       0x8E   0x0909             LSRS     R1,R1,#+4
   \       0x90   0x466A             MOV      R2,SP
   \       0x92   0x7051             STRB     R1,[R2, #+1]
    769          			aHex[auxIndex] = gaHexValue[hexIndex];
   \       0x94   0x....             LDR      R2,??DataTable9
   \       0x96   0xA906             ADD      R1,SP,#+24
   \       0x98   0x466B             MOV      R3,SP
   \       0x9A   0x785B             LDRB     R3,[R3, #+1]
   \       0x9C   0x5CD3             LDRB     R3,[R2, R3]
   \       0x9E   0x466D             MOV      R5,SP
   \       0xA0   0x782D             LDRB     R5,[R5, #+0]
   \       0xA2   0x554B             STRB     R3,[R1, R5]
    770          			hexIndex = value[cIndex] & 0x0f;
   \       0xA4   0x9B0C             LDR      R3,[SP, #+48]
   \       0xA6   0x003D             MOVS     R5,R7
   \       0xA8   0x062D             LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \       0xAA   0x0E2D             LSRS     R5,R5,#+24
   \       0xAC   0x5D5B             LDRB     R3,[R3, R5]
   \       0xAE   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \       0xB0   0x0F1B             LSRS     R3,R3,#+28
   \       0xB2   0x466D             MOV      R5,SP
   \       0xB4   0x706B             STRB     R3,[R5, #+1]
    771          			aHex[auxIndex + 1] = gaHexValue[hexIndex];
   \       0xB6   0x466B             MOV      R3,SP
   \       0xB8   0x785B             LDRB     R3,[R3, #+1]
   \       0xBA   0x5CD2             LDRB     R2,[R2, R3]
   \       0xBC   0x466B             MOV      R3,SP
   \       0xBE   0x781B             LDRB     R3,[R3, #+0]
   \       0xC0   0x18C9             ADDS     R1,R1,R3
   \       0xC2   0x704A             STRB     R2,[R1, #+1]
    772          		}
   \       0xC4   0x1C7F             ADDS     R7,R7,#+1
   \       0xC6   0x4669             MOV      R1,SP
   \       0xC8   0x7809             LDRB     R1,[R1, #+0]
   \       0xCA   0x1C89             ADDS     R1,R1,#+2
   \       0xCC   0x466A             MOV      R2,SP
   \       0xCE   0x7011             STRB     R1,[R2, #+0]
   \       0xD0   0xE7CD             B        ??LCD_WriteBytes_3
    773          		aHex[(length * 2)]='\0';
   \                     ??LCD_WriteBytes_4: (+1)
   \       0xD2   0xA906             ADD      R1,SP,#+24
   \       0xD4   0xAA0E             ADD      R2,SP,#+56
   \       0xD6   0x7812             LDRB     R2,[R2, #+0]
   \       0xD8   0x2302             MOVS     R3,#+2
   \       0xDA   0x435A             MULS     R2,R3,R2
   \       0xDC   0x5488             STRB     R0,[R1, R2]
   \       0xDE   0xE001             B        ??LCD_WriteBytes_5
    774          	}
    775          	else
    776          		counter = 0;
   \                     ??LCD_WriteBytes_2: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x0004             MOVS     R4,R0
    777          
    778          	i=0;
   \                     ??LCD_WriteBytes_5: (+1)
   \       0xE4   0x2100             MOVS     R1,#+0
   \       0xE6   0x000D             MOVS     R5,R1
    779          	while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c )
   \                     ??LCD_WriteBytes_6: (+1)
   \       0xE8   0xA806             ADD      R0,SP,#+24
   \       0xEA   0x002A             MOVS     R2,R5
   \       0xEC   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xEE   0x0E12             LSRS     R2,R2,#+24
   \       0xF0   0x5C82             LDRB     R2,[R0, R2]
   \       0xF2   0x2A00             CMP      R2,#+0
   \       0xF4   0xD010             BEQ      ??LCD_WriteBytes_7
   \       0xF6   0x0022             MOVS     R2,R4
   \       0xF8   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xFA   0x0E12             LSRS     R2,R2,#+24
   \       0xFC   0x2A15             CMP      R2,#+21
   \       0xFE   0xDA0B             BGE      ??LCD_WriteBytes_7
    780          		aString[counter++]=aHex[i++];
   \      0x100   0x002A             MOVS     R2,R5
   \      0x102   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x104   0x0E12             LSRS     R2,R2,#+24
   \      0x106   0x5C80             LDRB     R0,[R0, R2]
   \      0x108   0xAA01             ADD      R2,SP,#+4
   \      0x10A   0x0023             MOVS     R3,R4
   \      0x10C   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+24
   \      0x10E   0x0E1B             LSRS     R3,R3,#+24
   \      0x110   0x54D0             STRB     R0,[R2, R3]
   \      0x112   0x1C6D             ADDS     R5,R5,#+1
   \      0x114   0x1C64             ADDS     R4,R4,#+1
   \      0x116   0xE7E7             B        ??LCD_WriteBytes_6
    781          
    782          	aString[counter]='\0';
   \                     ??LCD_WriteBytes_7: (+1)
   \      0x118   0xA801             ADD      R0,SP,#+4
   \      0x11A   0x0022             MOVS     R2,R4
   \      0x11C   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \      0x11E   0x0E12             LSRS     R2,R2,#+24
   \      0x120   0x5481             STRB     R1,[R0, R2]
    783          	LCD_WriteString( line, aString );
   \      0x122   0xA901             ADD      R1,SP,#+4
   \      0x124   0xA80D             ADD      R0,SP,#+52
   \      0x126   0x7800             LDRB     R0,[R0, #+0]
   \      0x128   0x....'....        BL       LCD_WriteString
    784          }
   \      0x12C   0xB00F             ADD      SP,SP,#+60
   \      0x12E   0xBCF0             POP      {R4-R7}
   \      0x130   0xBC08             POP      {R3}
   \      0x132   0x4718             BX       R3               ;; return
    785          
    786          /******************************************************************************
    787          * This function sends a command to the display controller
    788          *
    789          * Interface assumptions:
    790          *
    791          *
    792          * Return value:
    793          * None
    794          *
    795          *
    796          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    797          void LCD_WriteCommand(uint8_t command)
    798          {
   \                     LCD_WriteCommand: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    799            /* clear the error indicator */
    800            mErrorIndicator = gLCD_NoError_c;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR      R1,??DataTable9_2
   \        0x8   0x7008             STRB     R0,[R1, #+0]
    801            
    802            Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2015             MOVS     R0,#+21
   \        0xE   0x....'....        BL       Gpio_SetPinData
    803            SetOutput();
   \       0x12   0x....'....        BL       SetOutput
    804            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x2014             MOVS     R0,#+20
   \       0x1A   0x....'....        BL       Gpio_SetPinData
    805            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x2009             MOVS     R0,#+9
   \       0x22   0x....'....        BL       Gpio_SetPinData
    806            SendData(command);
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x2A   0x0E00             LSRS     R0,R0,#+24
   \       0x2C   0x....'....        BL       SendData
    807            DelayUs(1);
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x....'....        BL       DelayUs
    808            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x2009             MOVS     R0,#+9
   \       0x3A   0x....'....        BL       Gpio_SetPinData
    809            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x2014             MOVS     R0,#+20
   \       0x42   0x....'....        BL       Gpio_SetPinData
    810            SetHiZ();
   \       0x46   0x....'....        BL       SetHiZ
    811            DelayUs(1);
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x....'....        BL       DelayUs
    812          }
   \       0x50   0xBC10             POP      {R4}
   \       0x52   0xBC08             POP      {R3}
   \       0x54   0x4718             BX       R3               ;; return
    813          
    814          /******************************************************************************
    815          * This function sends a data to the display controller
    816          *
    817          * Interface assumptions:
    818          *
    819          *
    820          * Return value:
    821          * None
    822          *
    823          *
    824          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    825          void LCD_WriteData(uint8_t data)
    826          {
   \                     LCD_WriteData: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    827            /* clear the error indicator */
    828            mErrorIndicator = gLCD_NoError_c;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR      R1,??DataTable9_2
   \        0x8   0x7008             STRB     R0,[R1, #+0]
    829          
    830            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2015             MOVS     R0,#+21
   \        0xE   0x....'....        BL       Gpio_SetPinData
    831            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x2014             MOVS     R0,#+20
   \       0x16   0x....'....        BL       Gpio_SetPinData
    832            SetOutput();
   \       0x1A   0x....'....        BL       SetOutput
    833            SendData(data);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x22   0x0E00             LSRS     R0,R0,#+24
   \       0x24   0x....'....        BL       SendData
    834            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x2009             MOVS     R0,#+9
   \       0x2C   0x....'....        BL       Gpio_SetPinData
    835            DelayUs(1);
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x....'....        BL       DelayUs
    836            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x2009             MOVS     R0,#+9
   \       0x3A   0x....'....        BL       Gpio_SetPinData
    837            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x2014             MOVS     R0,#+20
   \       0x42   0x....'....        BL       Gpio_SetPinData
    838            SetHiZ();
   \       0x46   0x....'....        BL       SetHiZ
    839            DelayUs(1);  
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x....'....        BL       DelayUs
    840           
    841          }
   \       0x50   0xBC10             POP      {R4}
   \       0x52   0xBC08             POP      {R3}
   \       0x54   0x4718             BX       R3               ;; return
    842          
    843          /******************************************************************************
    844          * This function sets the font received as parameter as default font
    845          *
    846          * Interface assumptions:
    847          *
    848          *
    849          * Return value:
    850          *      TRUE:  when the font is correctly set
    851          *      FALSE: when an unsupported font is received as parameter
    852          * char
    853          *
    854          *
    855          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    856          bool_t LCD_SetFont(lcdFontType_t font)
    857          {
   \                     LCD_SetFont: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    858            /* clear the error indicator */
    859            mErrorIndicator = gLCD_NoError_c;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR      R2,??DataTable9_2
   \        0x8   0x7010             STRB     R0,[R2, #+0]
    860          
    861            if(gLCDNumFonts_c > font)
   \        0xA   0x0008             MOVS     R0,R1
   \        0xC   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \        0xE   0x0E00             LSRS     R0,R0,#+24
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xDA03             BGE      ??LCD_SetFont_0
    862            {
    863              mDisplayParams.currentFontType = font;
   \       0x14   0x....             LDR      R0,??DataTable11
   \       0x16   0x7341             STRB     R1,[R0, #+13]
    864              return TRUE;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B        ??LCD_SetFont_1
    865            }
    866            else
    867            {
    868              return FALSE;
   \                     ??LCD_SetFont_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??LCD_SetFont_1: (+1)
   \       0x1E   0xBC08             POP      {R3}
   \       0x20   0x4718             BX       R3               ;; return
    869            }
    870          }
    871          
    872          /******************************************************************************
    873          * This function checks if an error occured during an interface function call.
    874          * User must always call this function to verify if an interface function executed 
    875          * successufully.
    876          *
    877          * Interface assumptions:
    878          *
    879          *
    880          * Return value:  lcdError_t
    881          *      gLCD_NoError_c:   no error
    882          *      gLCD_QueueFull_c: queue is full
    883          *
    884          *
    885          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    886          lcdError_t LCD_CheckError(void)
    887          {
    888            return mErrorIndicator;
   \                     LCD_CheckError: (+1)
   \        0x0   0x....             LDR      R0,??DataTable9_2
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    889          }
    890          
    891          /************************************************************************************
    892          *************************************************************************************
    893          * Private functions
    894          *************************************************************************************
    895          ************************************************************************************/
    896          
    897          
    898          /******************************************************************************
    899          * This function enables/disables the backlight
    900          *
    901          * Interface assumptions:
    902          *   0 - disable backlight
    903          *   >0 - enables backlight
    904          *
    905          *
    906          * Return value:
    907          * None
    908          *
    909          *
    910          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    911          void LCD_SetBacklight(uint8_t brightnessValue)
    912          {
   \                     LCD_SetBacklight: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    913              GpioPinState_t backLightState;
    914              backLightState = (0 != brightnessValue) ? gGpioPinStateHigh_c : gGpioPinStateLow_c;
   \        0x4   0x0028             MOVS     R0,R5
   \        0x6   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \        0x8   0x0E00             LSRS     R0,R0,#+24
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ      ??LCD_SetBacklight_0
   \        0xE   0x2401             MOVS     R4,#+1
   \       0x10   0xE000             B        ??LCD_SetBacklight_1
   \                     ??LCD_SetBacklight_0: (+1)
   \       0x12   0x2400             MOVS     R4,#+0
    915              Gpio_SetPinData(LCD_BL_PWM,  backLightState);
   \                     ??LCD_SetBacklight_1: (+1)
   \       0x14   0x0021             MOVS     R1,R4
   \       0x16   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x18   0x0E09             LSRS     R1,R1,#+24
   \       0x1A   0x200A             MOVS     R0,#+10
   \       0x1C   0x....'....        BL       Gpio_SetPinData
    916          }
   \       0x20   0xBC31             POP      {R0,R4,R5}
   \       0x22   0xBC08             POP      {R3}
   \       0x24   0x4718             BX       R3               ;; return
    917          
    918          /******************************************************************************
    919          * This function sets/ clears the pixel from (XStartCoord, YStartCoord)
    920          *
    921          * Interface assumptions:
    922          *
    923          *
    924          * Return value:
    925          * None
    926          *
    927          *
    928          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    929          void LCD_WritePixel(uint8_t xStartCoord, uint8_t yStartCoord, bool_t mode)
    930          {
   \                     LCD_WritePixel: (+1)
   \        0x0   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0008             MOVS     R0,R1
    931            uint8_t page;
    932            uint8_t read;
    933          
    934            if (xStartCoord>=gLCDMaxColumns_c || yStartCoord>=gLCDMaxLines_c)
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7909             LDRB     R1,[R1, #+4]
   \        0xA   0x2980             CMP      R1,#+128
   \        0xC   0xDA04             BGE      ??LCD_WritePixel_0
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x12   0x0E09             LSRS     R1,R1,#+24
   \       0x14   0x2940             CMP      R1,#+64
   \       0x16   0xDB00             BLT      ??LCD_WritePixel_1
    935            {
    936              return; /* if pixel out of screen exit */
   \                     ??LCD_WritePixel_0: (+1)
   \       0x18   0xE061             B        ??LCD_WritePixel_2
    937            }
    938          
    939            page = yStartCoord >> 3;
   \                     ??LCD_WritePixel_1: (+1)
   \       0x1A   0x0007             MOVS     R7,R0
   \       0x1C   0x063F             LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \       0x1E   0x0E3F             LSRS     R7,R7,#+24
   \       0x20   0x08FF             LSRS     R7,R7,#+3
    940            yStartCoord %= 8;
   \       0x22   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x24   0x0E00             LSRS     R0,R0,#+24
   \       0x26   0x2108             MOVS     R1,#+8
   \       0x28   0x....'....        BL       __aeabi_idivmod
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x7001             STRB     R1,[R0, #+0]
    941          
    942            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \       0x30   0x2040             MOVS     R0,#+64
   \       0x32   0x....'....        BL       LCD_WriteCommand
    943            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \       0x36   0x0038             MOVS     R0,R7
   \       0x38   0x3850             SUBS     R0,R0,#+80
   \       0x3A   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x3C   0x0E00             LSRS     R0,R0,#+24
   \       0x3E   0x....'....        BL       LCD_WriteCommand
    944            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \       0x42   0x2410             MOVS     R4,#+16
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x7900             LDRB     R0,[R0, #+4]
   \       0x48   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x4A   0x0E00             LSRS     R0,R0,#+24
   \       0x4C   0x0900             LSRS     R0,R0,#+4
   \       0x4E   0x4320             ORRS     R0,R0,R4
   \       0x50   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x52   0x0E00             LSRS     R0,R0,#+24
   \       0x54   0x....'....        BL       LCD_WriteCommand
    945            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));       
   \       0x58   0x250F             MOVS     R5,#+15
   \       0x5A   0x4668             MOV      R0,SP
   \       0x5C   0x7900             LDRB     R0,[R0, #+4]
   \       0x5E   0x4028             ANDS     R0,R0,R5
   \       0x60   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x62   0x0E00             LSRS     R0,R0,#+24
   \       0x64   0x....'....        BL       LCD_WriteCommand
    946          
    947            read = ReadData(); // Dummy read
   \       0x68   0x....'....        BL       ReadData
   \       0x6C   0x4669             MOV      R1,SP
   \       0x6E   0x7048             STRB     R0,[R1, #+1]
    948            read = ReadData();
   \       0x70   0x....'....        BL       ReadData
   \       0x74   0x0006             MOVS     R6,R0
    949          
    950            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \       0x76   0x2040             MOVS     R0,#+64
   \       0x78   0x....'....        BL       LCD_WriteCommand
    951            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \       0x7C   0x0038             MOVS     R0,R7
   \       0x7E   0x3850             SUBS     R0,R0,#+80
   \       0x80   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x82   0x0E00             LSRS     R0,R0,#+24
   \       0x84   0x....'....        BL       LCD_WriteCommand
    952            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \       0x88   0x4668             MOV      R0,SP
   \       0x8A   0x7900             LDRB     R0,[R0, #+4]
   \       0x8C   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x8E   0x0E00             LSRS     R0,R0,#+24
   \       0x90   0x0900             LSRS     R0,R0,#+4
   \       0x92   0x4304             ORRS     R4,R4,R0
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x98   0x0E00             LSRS     R0,R0,#+24
   \       0x9A   0x....'....        BL       LCD_WriteCommand
    953            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x7900             LDRB     R0,[R0, #+4]
   \       0xA2   0x4005             ANDS     R5,R5,R0
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0xA8   0x0E00             LSRS     R0,R0,#+24
   \       0xAA   0x....'....        BL       LCD_WriteCommand
    954          
    955            if( TRUE == mode )
   \       0xAE   0x4668             MOV      R0,SP
   \       0xB0   0x7A00             LDRB     R0,[R0, #+8]
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD109             BNE      ??LCD_WritePixel_3
    956            {
    957              LCD_WriteData((read | (1 << yStartCoord)));
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0x4669             MOV      R1,SP
   \       0xBA   0x7809             LDRB     R1,[R1, #+0]
   \       0xBC   0x4088             LSLS     R0,R0,R1
   \       0xBE   0x4330             ORRS     R0,R0,R6
   \       0xC0   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0xC2   0x0E00             LSRS     R0,R0,#+24
   \       0xC4   0x....'....        BL       LCD_WriteData
   \       0xC8   0xE009             B        ??LCD_WritePixel_4
    958            }
    959            else
    960            {  
    961              LCD_WriteData((read & ~(1 << yStartCoord)));  
   \                     ??LCD_WritePixel_3: (+1)
   \       0xCA   0x2101             MOVS     R1,#+1
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x7800             LDRB     R0,[R0, #+0]
   \       0xD0   0x4081             LSLS     R1,R1,R0
   \       0xD2   0x43C8             MVNS     R0,R1
   \       0xD4   0x4030             ANDS     R0,R0,R6
   \       0xD6   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0xD8   0x0E00             LSRS     R0,R0,#+24
   \       0xDA   0x....'....        BL       LCD_WriteData
    962            }
    963          }
   \                     ??LCD_WritePixel_4: (+1)
   \                     ??LCD_WritePixel_2: (+1)
   \       0xDE   0xBCF7             POP      {R0-R2,R4-R7}
   \       0xE0   0xBC08             POP      {R3}
   \       0xE2   0x4718             BX       R3               ;; return
    964          
    965          /******************************************************************************
    966          * This function displays a character starting with xCoord and yCoord
    967          *
    968          * Interface assumptions:
    969          *  yCoord is a multiple of 8
    970          *
    971          *
    972          * Return value:
    973          * None
    974          *
    975          *
    976          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    977          void LCD_WriteCharacter(uint8_t symbol, uint8_t xCoord, uint8_t yCoord)
    978          {
   \                     LCD_WriteCharacter: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    979            uint16_t arrayLocation=0; 
   \        0x4   0x2000             MOVS     R0,#+0
    980            uint8_t i, maxLength;
    981           
    982            /* if pixel out of screen, exit */
    983            if((xCoord >= gLCDMaxColumns_c) && (yCoord >= gLCDMaxLines_c))
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7B09             LDRB     R1,[R1, #+12]
   \        0xA   0x2980             CMP      R1,#+128
   \        0xC   0xDB03             BLT      ??LCD_WriteCharacter_0
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x7C09             LDRB     R1,[R1, #+16]
   \       0x12   0x2940             CMP      R1,#+64
   \       0x14   0xDA70             BGE      ??LCD_WriteCharacter_1
    984            {
    985              return;
    986            }
    987              
    988            arrayLocation = symbol - mFontOffset_c;
   \                     ??LCD_WriteCharacter_0: (+1)
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x7A09             LDRB     R1,[R1, #+8]
   \       0x1A   0x3920             SUBS     R1,R1,#+32
   \       0x1C   0x466A             MOV      R2,SP
   \       0x1E   0x8011             STRH     R1,[R2, #+0]
    989            maxLength = aLCDFont[mDisplayParams.currentFontType].fontHeight;
   \       0x20   0x....             LDR      R5,??DataTable11
   \       0x22   0x....             LDR      R6,??DataTable11_1
   \       0x24   0x7B69             LDRB     R1,[R5, #+13]
   \       0x26   0x220C             MOVS     R2,#+12
   \       0x28   0x4351             MULS     R1,R2,R1
   \       0x2A   0x1871             ADDS     R1,R6,R1
   \       0x2C   0x7A0F             LDRB     R7,[R1, #+8]
    990            /* each character has: 
    991            *  (aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation+1] - 
    992            *   aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation]) pixels as width 
    993            *  (aLCDFont[mDisplayParams.currentFontType].fontHeight * 8) pixels as height 
    994            */
    995            while(maxLength > 0)
   \                     ??LCD_WriteCharacter_2: (+1)
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x32   0x0E00             LSRS     R0,R0,#+24
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD05F             BEQ      ??LCD_WriteCharacter_3
    996            {
    997              maxLength--;      
   \       0x38   0x1E7F             SUBS     R7,R7,#+1
    998              InitDisplayWrite(xCoord,yCoord);        
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x7C01             LDRB     R1,[R0, #+16]
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x7B00             LDRB     R0,[R0, #+12]
   \       0x42   0x....'....        BL       InitDisplayWrite
    999              /* mark line as written */
   1000              mDisplayParams.writtenLines |= (1<<(yCoord>>3));   
   \       0x46   0x78E9             LDRB     R1,[R5, #+3]
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0x466A             MOV      R2,SP
   \       0x4C   0x7C12             LDRB     R2,[R2, #+16]
   \       0x4E   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x50   0x0E12             LSRS     R2,R2,#+24
   \       0x52   0x08D2             LSRS     R2,R2,#+3
   \       0x54   0x4090             LSLS     R0,R0,R2
   \       0x56   0x4308             ORRS     R0,R0,R1
   \       0x58   0x70E8             STRB     R0,[R5, #+3]
   1001              for(i = 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x0004             MOVS     R4,R0
   1002                  i < ((aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation+1] - 
   1003                        aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]) *
   1004                        aLCDFont[mDisplayParams.currentFontType].fontHeight);
   \                     ??LCD_WriteCharacter_4: (+1)
   \       0x5E   0x0022             MOVS     R2,R4
   \       0x60   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x62   0x0E12             LSRS     R2,R2,#+24
   \       0x64   0x7B68             LDRB     R0,[R5, #+13]
   \       0x66   0x210C             MOVS     R1,#+12
   \       0x68   0x4348             MULS     R0,R1,R0
   \       0x6A   0x5830             LDR      R0,[R6, R0]
   \       0x6C   0x4669             MOV      R1,SP
   \       0x6E   0x8809             LDRH     R1,[R1, #+0]
   \       0x70   0x2302             MOVS     R3,#+2
   \       0x72   0x434B             MULS     R3,R1,R3
   \       0x74   0x18C0             ADDS     R0,R0,R3
   \       0x76   0x8843             LDRH     R3,[R0, #+2]
   \       0x78   0x7B68             LDRB     R0,[R5, #+13]
   \       0x7A   0x210C             MOVS     R1,#+12
   \       0x7C   0x4348             MULS     R0,R1,R0
   \       0x7E   0x5831             LDR      R1,[R6, R0]
   \       0x80   0x468C             MOV      R12,R1
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x8801             LDRH     R1,[R0, #+0]
   \       0x86   0x2002             MOVS     R0,#+2
   \       0x88   0x4348             MULS     R0,R1,R0
   \       0x8A   0x4661             MOV      R1,R12
   \       0x8C   0x5A08             LDRH     R0,[R1, R0]
   \       0x8E   0x1A18             SUBS     R0,R3,R0
   \       0x90   0x7B69             LDRB     R1,[R5, #+13]
   \       0x92   0x230C             MOVS     R3,#+12
   \       0x94   0x4359             MULS     R1,R3,R1
   \       0x96   0x1871             ADDS     R1,R6,R1
   \       0x98   0x7A09             LDRB     R1,[R1, #+8]
   \       0x9A   0x4348             MULS     R0,R1,R0
   \       0x9C   0x4282             CMP      R2,R0
   \       0x9E   0xDA25             BGE      ??LCD_WriteCharacter_5
   1005                  i += aLCDFont[mDisplayParams.currentFontType].fontHeight)        
   1006              {
   1007                /* in case the character is representd on multiple lines,
   1008                 * (aLCDFont[mDisplayParams.currentFontType].fontHeight > 1),
   1009                 * display first the upper part of the character and after the lower part 
   1010                 */
   1011                LCD_WriteData(aLCDFont[mDisplayParams.currentFontType].pFontCharTable[aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]*aLCDFont[mDisplayParams.currentFontType].fontHeight + i + maxLength]);
   \       0xA0   0x7B68             LDRB     R0,[R5, #+13]
   \       0xA2   0x210C             MOVS     R1,#+12
   \       0xA4   0x4348             MULS     R0,R1,R0
   \       0xA6   0x1830             ADDS     R0,R6,R0
   \       0xA8   0x6840             LDR      R0,[R0, #+4]
   \       0xAA   0x7B69             LDRB     R1,[R5, #+13]
   \       0xAC   0x220C             MOVS     R2,#+12
   \       0xAE   0x4351             MULS     R1,R2,R1
   \       0xB0   0x5871             LDR      R1,[R6, R1]
   \       0xB2   0x466A             MOV      R2,SP
   \       0xB4   0x8812             LDRH     R2,[R2, #+0]
   \       0xB6   0x2302             MOVS     R3,#+2
   \       0xB8   0x4353             MULS     R3,R2,R3
   \       0xBA   0x5AC9             LDRH     R1,[R1, R3]
   \       0xBC   0x7B6A             LDRB     R2,[R5, #+13]
   \       0xBE   0x230C             MOVS     R3,#+12
   \       0xC0   0x435A             MULS     R2,R3,R2
   \       0xC2   0x18B2             ADDS     R2,R6,R2
   \       0xC4   0x7A12             LDRB     R2,[R2, #+8]
   \       0xC6   0x434A             MULS     R2,R1,R2
   \       0xC8   0x0021             MOVS     R1,R4
   \       0xCA   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0xCC   0x0E09             LSRS     R1,R1,#+24
   \       0xCE   0x1851             ADDS     R1,R2,R1
   \       0xD0   0x003A             MOVS     R2,R7
   \       0xD2   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0xD4   0x0E12             LSRS     R2,R2,#+24
   \       0xD6   0x1889             ADDS     R1,R1,R2
   \       0xD8   0x5C40             LDRB     R0,[R0, R1]
   \       0xDA   0x....'....        BL       LCD_WriteData
   1012              }
   \       0xDE   0x7B68             LDRB     R0,[R5, #+13]
   \       0xE0   0x210C             MOVS     R1,#+12
   \       0xE2   0x4348             MULS     R0,R1,R0
   \       0xE4   0x1830             ADDS     R0,R6,R0
   \       0xE6   0x7A00             LDRB     R0,[R0, #+8]
   \       0xE8   0x1824             ADDS     R4,R4,R0
   \       0xEA   0xE7B8             B        ??LCD_WriteCharacter_4
   1013              yCoord += 8;
   \                     ??LCD_WriteCharacter_5: (+1)
   \       0xEC   0x4668             MOV      R0,SP
   \       0xEE   0x7C00             LDRB     R0,[R0, #+16]
   \       0xF0   0x3008             ADDS     R0,R0,#+8
   \       0xF2   0x4669             MOV      R1,SP
   \       0xF4   0x7408             STRB     R0,[R1, #+16]
   \       0xF6   0xE79A             B        ??LCD_WriteCharacter_2
   1014            }    
   1015          }
   \                     ??LCD_WriteCharacter_3: (+1)
   \                     ??LCD_WriteCharacter_1: (+1)
   \       0xF8   0xB005             ADD      SP,SP,#+20
   \       0xFA   0xBCF0             POP      {R4-R7}
   \       0xFC   0xBC08             POP      {R3}
   \       0xFE   0x4718             BX       R3               ;; return
   1016          
   1017          /****************************************************************************************
   1018          * This function clears the pixels between startXCoord and endXCoord within a single page
   1019          * (page located at yCoord)
   1020          *
   1021          * Interface assumptions:
   1022          *
   1023          *
   1024          * Return value:
   1025          * None
   1026          *
   1027          *
   1028          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1029          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord)
   1030          {
   \                     LCD_ClearPage: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0017             MOVS     R7,R2
   1031            uint8_t i;
   1032            
   1033            InitDisplayWrite(startXCoord, yCoord);
   \        0x8   0x0039             MOVS     R1,R7
   \        0xA   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \        0xC   0x0E09             LSRS     R1,R1,#+24
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x12   0x0E00             LSRS     R0,R0,#+24
   \       0x14   0x....'....        BL       InitDisplayWrite
   1034            for(i = startXCoord; i < endXCoord; i++)
   \       0x18   0x002E             MOVS     R6,R5
   \                     ??LCD_ClearPage_0: (+1)
   \       0x1A   0x0030             MOVS     R0,R6
   \       0x1C   0x0021             MOVS     R1,R4
   \       0x1E   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x20   0x0E00             LSRS     R0,R0,#+24
   \       0x22   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x24   0x0E09             LSRS     R1,R1,#+24
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD204             BCS      ??LCD_ClearPage_1
   1035            {
   1036              LCD_WriteData(OFF);    
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x....'....        BL       LCD_WriteData
   1037            }    
   \       0x30   0x1C76             ADDS     R6,R6,#+1
   \       0x32   0xE7F2             B        ??LCD_ClearPage_0
   1038          }
   \                     ??LCD_ClearPage_1: (+1)
   \       0x34   0xBCF1             POP      {R0,R4-R7}
   \       0x36   0xBC08             POP      {R3}
   \       0x38   0x4718             BX       R3               ;; return
   1039          
   1040          /****************************************************************************************
   1041          * This function clears an entire LCD line
   1042          *
   1043          * Interface assumptions:
   1044          *     char line = 0..7
   1045          *
   1046          *
   1047          * Return value:
   1048          *     TRUE if the line was cleared
   1049          *     FALSE if the line is not cleared yet
   1050          *     0xFF  if the line parameter is not valid
   1051          * None
   1052          *
   1053          *
   1054          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1055          uint8_t LCD_ClearLine(uint8_t line)
   1056          {
   \                     LCD_ClearLine: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   1057            static pageParams_t pageToDelete;
   1058            static bool_t isPageDeleted = TRUE;
   1059            
   1060            if(line < gLCDMaxRamDataPages_c)
   \        0x4   0x0030             MOVS     R0,R6
   \        0x6   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \        0x8   0x0E00             LSRS     R0,R0,#+24
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xDA35             BGE      ??LCD_ClearLine_0
   1061            {
   1062              /* save the page coordinates */
   1063              if(isPageDeleted)
   \        0xE   0x....             LDR      R5,??DataTable11_2
   \       0x10   0x7828             LDRB     R0,[R5, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD013             BEQ      ??LCD_ClearLine_1
   1064              {
   1065                pageToDelete.xStartCoord = mLineParams[line].xCoord;
   \       0x16   0x....             LDR      R0,??DataTable11_3
   \       0x18   0x....             LDR      R1,??DataTable11_4
   \       0x1A   0x0032             MOVS     R2,R6
   \       0x1C   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x1E   0x0E12             LSRS     R2,R2,#+24
   \       0x20   0x2303             MOVS     R3,#+3
   \       0x22   0x435A             MULS     R2,R3,R2
   \       0x24   0x5C8A             LDRB     R2,[R1, R2]
   \       0x26   0x7002             STRB     R2,[R0, #+0]
   1066                pageToDelete.xEndCoord   = gLCDMaxColumns_c;
   \       0x28   0x2280             MOVS     R2,#+128
   \       0x2A   0x7042             STRB     R2,[R0, #+1]
   1067                pageToDelete.yCoord      = mLineParams[line].yCoord;
   \       0x2C   0x0032             MOVS     R2,R6
   \       0x2E   0x0612             LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \       0x30   0x0E12             LSRS     R2,R2,#+24
   \       0x32   0x2303             MOVS     R3,#+3
   \       0x34   0x435A             MULS     R2,R3,R2
   \       0x36   0x1889             ADDS     R1,R1,R2
   \       0x38   0x7849             LDRB     R1,[R1, #+1]
   \       0x3A   0x7081             STRB     R1,[R0, #+2]
   1068                pageToDelete.line        = line; 
   \       0x3C   0x70C6             STRB     R6,[R0, #+3]
   1069              }
   1070              
   1071              /* delete only mMaxDeleteColumns_c columns once because of time constraints */
   1072              if(((pageToDelete.xEndCoord - pageToDelete.xStartCoord) >= mMaxDeleteColumns_c))
   \                     ??LCD_ClearLine_1: (+1)
   \       0x3E   0x....             LDR      R4,??DataTable11_3
   \       0x40   0x7860             LDRB     R0,[R4, #+1]
   \       0x42   0x7821             LDRB     R1,[R4, #+0]
   \       0x44   0x1A40             SUBS     R0,R0,R1
   \       0x46   0x2820             CMP      R0,#+32
   \       0x48   0xDB0E             BLT      ??LCD_ClearLine_2
   1073              {
   1074                /* the page will be deleted with (gLCDMaxColumns_c/mMaxDeleteColumns_c) consecutive operations */
   1075                isPageDeleted            = FALSE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x7028             STRB     R0,[R5, #+0]
   1076                LCD_ClearPage(pageToDelete.xStartCoord, 
   1077                              pageToDelete.xStartCoord + mMaxDeleteColumns_c, 
   1078                              pageToDelete.yCoord); 
   \       0x4E   0x78A2             LDRB     R2,[R4, #+2]
   \       0x50   0x7821             LDRB     R1,[R4, #+0]
   \       0x52   0x3120             ADDS     R1,R1,#+32
   \       0x54   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x56   0x0E09             LSRS     R1,R1,#+24
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0x....'....        BL       LCD_ClearPage
   1079                /* compute the new xStartCoord for the current page */
   1080                pageToDelete.xStartCoord = pageToDelete.xStartCoord + mMaxDeleteColumns_c;        
   \       0x5E   0x7820             LDRB     R0,[R4, #+0]
   \       0x60   0x3020             ADDS     R0,R0,#+32
   \       0x62   0x7020             STRB     R0,[R4, #+0]
   1081                return FALSE;  
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE009             B        ??LCD_ClearLine_3
   1082              }
   1083              else
   1084              {    
   1085                LCD_ClearPage(pageToDelete.xStartCoord, 
   1086                              pageToDelete.xEndCoord, 
   1087                              pageToDelete.yCoord);
   \                     ??LCD_ClearLine_2: (+1)
   \       0x68   0x78A2             LDRB     R2,[R4, #+2]
   \       0x6A   0x7861             LDRB     R1,[R4, #+1]
   \       0x6C   0x7820             LDRB     R0,[R4, #+0]
   \       0x6E   0x....'....        BL       LCD_ClearPage
   1088                isPageDeleted            = TRUE;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x7028             STRB     R0,[R5, #+0]
   1089                return TRUE;  
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xE000             B        ??LCD_ClearLine_3
   1090              } 
   1091            }
   1092            else
   1093            {
   1094              return 0xFF;
   \                     ??LCD_ClearLine_0: (+1)
   \       0x7A   0x20FF             MOVS     R0,#+255
   \                     ??LCD_ClearLine_3: (+1)
   \       0x7C   0xBC70             POP      {R4-R6}
   \       0x7E   0xBC08             POP      {R3}
   \       0x80   0x4718             BX       R3               ;; return
   1095            }
   1096          }

   \                                 In section .bss, align 4
   \                     `LCD_ClearLine::pageToDelete`:
   \        0x0                      DS8 4

   \                                 In section .data, align 1
   \                     `LCD_ClearLine::isPageDeleted`:
   \        0x0   0x01               DC8 1
   1097          
   1098          /******************************************************************************
   1099          * This function process an LCD operation (clear, write string).
   1100          *
   1101          * Interface assumptions:
   1102          *
   1103          *
   1104          * Return value:
   1105          * None
   1106          *
   1107          *
   1108          ******************************************************************************/
   1109          
   1110          
   1111          /******************************************************************************
   1112          * This function sets a certain value to the LCD DATA pins
   1113          *
   1114          * Interface assumptions:
   1115          *
   1116          *
   1117          * Return value:
   1118          * None
   1119          *
   1120          *
   1121          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1122          static void SendData(uint8_t data)
   1123          {
   \                     SendData: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1124          #if gLCDGpioPinMode_c
   1125              /* bit |7|6|5|4|3|2|1|0| */
   1126              (void)Gpio_SetPinData(LCD_D0, (data & 0x01)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1127              (void)Gpio_SetPinData(LCD_D1, (data & 0x02)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1128              (void)Gpio_SetPinData(LCD_D2, (data & 0x04)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1129              (void)Gpio_SetPinData(LCD_D3, (data & 0x08)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1130              (void)Gpio_SetPinData(LCD_D4, (data & 0x10)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1131              (void)Gpio_SetPinData(LCD_D5, (data & 0x20)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1132              (void)Gpio_SetPinData(LCD_D6, (data & 0x40)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1133              (void)Gpio_SetPinData(LCD_D7, (data & 0x80)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1134          #else /* gLCDGpioPinMode_c */    
   1135              Gpio_SetPortData(LCD_DATA_LO_PORT, LCD_DATA_LO_WRITE(data), LCD_DATA_LO_MASK); 
   \        0x4   0x22F0             MOVS     R2,#+240
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \        0xA   0x0E00             LSRS     R0,R0,#+24
   \        0xC   0x0101             LSLS     R1,R0,#+4
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x....'....        BL       Gpio_SetPortData
   1136              Gpio_SetPortData(LCD_DATA_HI_PORT, LCD_DATA_HI_WRITE(data), LCD_DATA_HI_MASK);
   \       0x14   0x220F             MOVS     R2,#+15
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x1A   0x0E09             LSRS     R1,R1,#+24
   \       0x1C   0x0909             LSRS     R1,R1,#+4
   \       0x1E   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x20   0x0E09             LSRS     R1,R1,#+24
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x....'....        BL       Gpio_SetPortData
   1137              
   1138          #endif /* gLCDGpioPinMode_c */     
   1139          }
   \       0x28   0xBC10             POP      {R4}
   \       0x2A   0xBC08             POP      {R3}
   \       0x2C   0x4718             BX       R3               ;; return
   1140          
   1141          /******************************************************************************
   1142          * This function sets the LCD DATA pins as inputs
   1143          *
   1144          * Interface assumptions:
   1145          *
   1146          *
   1147          * Return value:
   1148          * None
   1149          *
   1150          *
   1151          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1152          static void SetHiZ(void)
   1153          {
   \                     SetHiZ: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1154              /* change data pins direction back to input */
   1155          #if gLCDGpioPinMode_c
   1156              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
   1157              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
   1158              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
   1159              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
   1160              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
   1161              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
   1162              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
   1163              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
   1164          #else /* gLCDGpioPinMode_c */ 
   1165              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK); 
   \        0x2   0x22F0             MOVS     R2,#+240
   \        0x4   0x21F0             MOVS     R1,#+240
   \        0x6   0x43C9             MVNS     R1,R1            ;; #-241
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....'....        BL       Gpio_SetPortDir
   1166              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK); 
   \        0xE   0x220F             MOVS     R2,#+15
   \       0x10   0x210F             MOVS     R1,#+15
   \       0x12   0x43C9             MVNS     R1,R1            ;; #-16
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x....'....        BL       Gpio_SetPortDir
   1167              
   1168          #endif /* gLCDGpioPinMode_c */
   1169          
   1170          }
   \       0x1A   0xBC09             POP      {R0,R3}
   \       0x1C   0x4718             BX       R3               ;; return
   1171          
   1172          /******************************************************************************
   1173          * This function sets the LCD DATA pins as outputs
   1174          *
   1175          * Interface assumptions:
   1176          *
   1177          *
   1178          * Return value:
   1179          * None
   1180          *
   1181          *
   1182          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1183          static void SetOutput(void)
   1184          {
   \                     SetOutput: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1185            /* change data pins direction to output */
   1186          #if gLCDGpioPinMode_c
   1187            (void)Gpio_SetPinDir(LCD_D0,      gGpioDirOut_c);
   1188            (void)Gpio_SetPinDir(LCD_D1,      gGpioDirOut_c);
   1189            (void)Gpio_SetPinDir(LCD_D2,      gGpioDirOut_c);
   1190            (void)Gpio_SetPinDir(LCD_D3,      gGpioDirOut_c);
   1191            (void)Gpio_SetPinDir(LCD_D4,      gGpioDirOut_c);
   1192            (void)Gpio_SetPinDir(LCD_D5,      gGpioDirOut_c);
   1193            (void)Gpio_SetPinDir(LCD_D6,      gGpioDirOut_c);
   1194            (void)Gpio_SetPinDir(LCD_D7,      gGpioDirOut_c);
   1195          #else /* gLCDGpioPinMode_c */
   1196             
   1197              Gpio_SetPortDir(LCD_DATA_LO_PORT, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);      
   \        0x2   0x22F0             MOVS     R2,#+240
   \        0x4   0x21F0             MOVS     R1,#+240
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        BL       Gpio_SetPortDir
   1198              Gpio_SetPortDir(LCD_DATA_HI_PORT, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);         
   \        0xC   0x220F             MOVS     R2,#+15
   \        0xE   0x210F             MOVS     R1,#+15
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x....'....        BL       Gpio_SetPortDir
   1199              
   1200          #endif /* gLCDGpioPinMode_c */
   1201          
   1202          }
   \       0x16   0xBC09             POP      {R0,R3}
   \       0x18   0x4718             BX       R3               ;; return
   1203          
   1204          /******************************************************************************
   1205          * This function initilizes the display for a data write (line, page, column)
   1206          *
   1207          * Interface assumptions:
   1208          *
   1209          *
   1210          * Return value:
   1211          * None
   1212          *
   1213          *
   1214          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1215          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord)
   1216          {
   \                     InitDisplayWrite: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1217          
   1218            uint8_t page;  
   1219            
   1220            page = yStartCoord >> 3;
   \        0x6   0x0026             MOVS     R6,R4
   \        0x8   0x0636             LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \        0xA   0x0E36             LSRS     R6,R6,#+24
   \        0xC   0x08F6             LSRS     R6,R6,#+3
   1221          
   1222            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \        0xE   0x2040             MOVS     R0,#+64
   \       0x10   0x....'....        BL       LCD_WriteCommand
   1223            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0x3850             SUBS     R0,R0,#+80
   \       0x18   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x1A   0x0E00             LSRS     R0,R0,#+24
   \       0x1C   0x....'....        BL       LCD_WriteCommand
   1224            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x24   0x0E09             LSRS     R1,R1,#+24
   \       0x26   0x0909             LSRS     R1,R1,#+4
   \       0x28   0x2010             MOVS     R0,#+16
   \       0x2A   0x4308             ORRS     R0,R0,R1
   \       0x2C   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x2E   0x0E00             LSRS     R0,R0,#+24
   \       0x30   0x....'....        BL       LCD_WriteCommand
   1225            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));         
   \       0x34   0x0728             LSLS     R0,R5,#+28       ;; ZeroExtS R0,R5,#+28,#+28
   \       0x36   0x0F00             LSRS     R0,R0,#+28
   \       0x38   0x....'....        BL       LCD_WriteCommand
   1226          }
   \       0x3C   0xBC70             POP      {R4-R6}
   \       0x3E   0xBC08             POP      {R3}
   \       0x40   0x4718             BX       R3               ;; return
   1227          
   1228          /******************************************************************************
   1229          * This function reads the current location from display data RAM
   1230          *
   1231          * Interface assumptions:
   1232          *
   1233          *
   1234          * Return value:
   1235          * None
   1236          *
   1237          *
   1238          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1239          static uint8_t ReadData(void)
   1240          {
   \                     ReadData: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1241            uint8_t ReturnValue;
   1242            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2015             MOVS     R0,#+21
   \        0x6   0x....'....        BL       Gpio_SetPinData
   1243            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2014             MOVS     R0,#+20
   \        0xE   0x....'....        BL       Gpio_SetPinData
   1244            DelayUs(1);
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x....'....        BL       DelayUs
   1245            Gpio_SetPinData(LCD_RD, LCD_RD_ACTIVE);
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x2008             MOVS     R0,#+8
   \       0x1C   0x....'....        BL       Gpio_SetPinData
   1246            DelayUs(1);
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0x....'....        BL       DelayUs
   1247            ReturnValue = GetData();
   \       0x26   0x....'....        BL       GetData
   \       0x2A   0x0004             MOVS     R4,R0
   1248            Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x2008             MOVS     R0,#+8
   \       0x30   0x....'....        BL       Gpio_SetPinData
   1249            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x2014             MOVS     R0,#+20
   \       0x38   0x....'....        BL       Gpio_SetPinData
   1250            DelayUs(1);
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x....'....        BL       DelayUs
   1251            return ReturnValue;
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x46   0x0E00             LSRS     R0,R0,#+24
   \       0x48   0xBC10             POP      {R4}
   \       0x4A   0xBC08             POP      {R3}
   \       0x4C   0x4718             BX       R3               ;; return
   1252          }
   1253          
   1254          /******************************************************************************
   1255          * This function sets the data from the current RAM display location
   1256          * to LCD DATA pins
   1257          *
   1258          * Interface assumptions:
   1259          *
   1260          *
   1261          * Return value:
   1262          * unsigned 8 bit
   1263          *
   1264          *
   1265          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1266          static uint8_t GetData(void)
   1267          {
   \                     GetData: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1268              uint8_t        ReturnValue = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   1269          #if gLCDGpioPinMode_c
   1270              GpioPinState_t Bitdata;
   1271              /* bit |7|6|5|4|3|2|1|0| */
   1272              Gpio_GetPinData(LCD_D7, &Bitdata);
   1273              ReturnValue = (Bitdata)? (1<<7) : 0;
   1274              Gpio_GetPinData(LCD_D6, &Bitdata);
   1275              ReturnValue |= (Bitdata)? (1<<6) : 0;
   1276              Gpio_GetPinData(LCD_D5, &Bitdata);
   1277              ReturnValue |= (Bitdata)? (1<<5) : 0;
   1278              Gpio_GetPinData(LCD_D4, &Bitdata);
   1279              ReturnValue |= (Bitdata)? (1<<4) : 0;
   1280              Gpio_GetPinData(LCD_D3, &Bitdata);
   1281              ReturnValue |= (Bitdata)? (1<<3) : 0;
   1282              Gpio_GetPinData(LCD_D2, &Bitdata);
   1283              ReturnValue |= (Bitdata)? (1<<2) : 0;
   1284              Gpio_GetPinData(LCD_D1, &Bitdata);
   1285              ReturnValue |= (Bitdata)? (1<<1) : 0;
   1286              Gpio_GetPinData(LCD_D0, &Bitdata);
   1287              ReturnValue |= (Bitdata)? (1<<0) : 0;
   1288              
   1289          #else /* gLCDGpioPinMode_c */
   1290              uint32_t temp;
   1291              Gpio_GetPortData(LCD_DATA_LO_PORT, &temp);
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        BL       Gpio_GetPortData
   1292              ReturnValue = LCD_DATA_LO_READ(LCD_DATA_LO_MASK & temp);
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x0900             LSRS     R0,R0,#+4
   \       0x10   0x0705             LSLS     R5,R0,#+28       ;; ZeroExtS R5,R0,#+28,#+28
   \       0x12   0x0F2D             LSRS     R5,R5,#+28
   1293              Gpio_GetPortData(LCD_DATA_HI_PORT, &temp);
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x....'....        BL       Gpio_GetPortData
   1294              ReturnValue |= LCD_DATA_HI_READ(LCD_DATA_HI_MASK & temp);
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x0100             LSLS     R0,R0,#+4
   \       0x20   0x4328             ORRS     R0,R0,R5
   1295          
   1296          #endif /* gLCDGpioPinMode_c */
   1297              
   1298              return ReturnValue;
   \       0x22   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x24   0x0E00             LSRS     R0,R0,#+24
   \       0x26   0xBC32             POP      {R1,R4,R5}
   \       0x28   0xBC08             POP      {R3}
   \       0x2A   0x4718             BX       R3               ;; return
   1299          }
   1300          
   1301          /******************************************************************************
   1302          * This function gets the length of a string and return the length
   1303          *
   1304          * Interface assumptions:
   1305          *
   1306          *
   1307          * Return value:
   1308          * char
   1309          *
   1310          *
   1311          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1312          static uint8_t GetStrlen
   1313            (
   1314            const uint8_t *pString /* IN: Pointer to text string */
   1315            )
   1316          {
   \                     GetStrlen: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   1317            int8_t count=0, length=0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0002             MOVS     R2,R0
   1318          
   1319            while (*pString != '\0' && count <gMAX_LCD_CHARS_c ) {
   \                     ??GetStrlen_0: (+1)
   \        0x8   0x780B             LDRB     R3,[R1, #+0]
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD008             BEQ      ??GetStrlen_1
   \        0xE   0x0013             MOVS     R3,R2
   \       0x10   0x061B             LSLS     R3,R3,#+24       ;; SignExtS R3,R3,#+24,#+24
   \       0x12   0x161B             ASRS     R3,R3,#+24
   \       0x14   0x2B15             CMP      R3,#+21
   \       0x16   0xDA03             BGE      ??GetStrlen_1
   1320              count++;
   \       0x18   0x1C52             ADDS     R2,R2,#+1
   1321              length++;
   \       0x1A   0x1C40             ADDS     R0,R0,#+1
   1322              pString++;
   \       0x1C   0x1C49             ADDS     R1,R1,#+1
   \       0x1E   0xE7F3             B        ??GetStrlen_0
   1323            }
   1324          
   1325            /* Check boundries */
   1326            if ( length > gMAX_LCD_CHARS_c ) {
   \                     ??GetStrlen_1: (+1)
   \       0x20   0x0003             MOVS     R3,R0
   \       0x22   0x061B             LSLS     R3,R3,#+24       ;; SignExtS R3,R3,#+24,#+24
   \       0x24   0x161B             ASRS     R3,R3,#+24
   \       0x26   0x2B16             CMP      R3,#+22
   \       0x28   0xDB01             BLT      ??GetStrlen_2
   1327              length = gMAX_LCD_CHARS_c;
   \       0x2A   0x2315             MOVS     R3,#+21
   \       0x2C   0x0018             MOVS     R0,R3
   1328            }
   1329          
   1330            return length;
   \                     ??GetStrlen_2: (+1)
   \       0x2E   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x30   0x0E00             LSRS     R0,R0,#+24
   \       0x32   0xBC08             POP      {R3}
   \       0x34   0x4718             BX       R3               ;; return
   1331          }
   1332          
   1333          /******************************************************************************
   1334          * This function draws a 24x24 pixels Icon
   1335          *
   1336          * Interface assumptions:
   1337          *
   1338          *
   1339          * Return value:
   1340          * char
   1341          *
   1342          *
   1343          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1344          void LCD_DrawIcon(uint8_t u8XCoord, uint8_t u8YPage, uint8_t * pu8Icon)
   1345          {
   \                     LCD_DrawIcon: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0x000F             MOVS     R7,R1
   \        0x4   0x0014             MOVS     R4,R2
   1346            uint8_t u8i;
   1347            uint8_t u8j;
   1348            
   1349            if (u8XCoord >= gLCDMaxColumns_c || u8YPage >= gLCDMaxRamDataPages_c)
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x2880             CMP      R0,#+128
   \        0xC   0xDA04             BGE      ??LCD_DrawIcon_0
   \        0xE   0x0038             MOVS     R0,R7
   \       0x10   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x12   0x0E00             LSRS     R0,R0,#+24
   \       0x14   0x2808             CMP      R0,#+8
   \       0x16   0xDB00             BLT      ??LCD_DrawIcon_1
   1350            {
   1351              return; /* if pixel out of screen exit */
   \                     ??LCD_DrawIcon_0: (+1)
   \       0x18   0xE030             B        ??LCD_DrawIcon_2
   1352            }
   1353          
   1354            for(u8i = 0; u8i < 3; u8i++)
   \                     ??LCD_DrawIcon_1: (+1)
   \       0x1A   0x2600             MOVS     R6,#+0
   \                     ??LCD_DrawIcon_3: (+1)
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x20   0x0E00             LSRS     R0,R0,#+24
   \       0x22   0x2803             CMP      R0,#+3
   \       0x24   0xDA2A             BGE      ??LCD_DrawIcon_4
   1355            {
   1356              LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \       0x26   0x2040             MOVS     R0,#+64
   \       0x28   0x....'....        BL       LCD_WriteCommand
   1357              LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + u8YPage++);
   \       0x2C   0x0038             MOVS     R0,R7
   \       0x2E   0x3850             SUBS     R0,R0,#+80
   \       0x30   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x32   0x0E00             LSRS     R0,R0,#+24
   \       0x34   0x....'....        BL       LCD_WriteCommand
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   1358              LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((u8XCoord & 0xF0)>>4));
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x0001             MOVS     R1,R0
   \       0x40   0x0609             LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \       0x42   0x0E09             LSRS     R1,R1,#+24
   \       0x44   0x0909             LSRS     R1,R1,#+4
   \       0x46   0x2010             MOVS     R0,#+16
   \       0x48   0x4308             ORRS     R0,R0,R1
   \       0x4A   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x4C   0x0E00             LSRS     R0,R0,#+24
   \       0x4E   0x....'....        BL       LCD_WriteCommand
   1359              LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (u8XCoord & 0x0F));
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x7800             LDRB     R0,[R0, #+0]
   \       0x56   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \       0x58   0x0F00             LSRS     R0,R0,#+28
   \       0x5A   0x....'....        BL       LCD_WriteCommand
   1360              for(u8j = 0; u8j < 24; u8j++)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x0005             MOVS     R5,R0
   \                     ??LCD_DrawIcon_5: (+1)
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x0600             LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \       0x66   0x0E00             LSRS     R0,R0,#+24
   \       0x68   0x2818             CMP      R0,#+24
   \       0x6A   0xDA05             BGE      ??LCD_DrawIcon_6
   1361              {
   1362                LCD_WriteData(*pu8Icon); 
   \       0x6C   0x7820             LDRB     R0,[R4, #+0]
   \       0x6E   0x....'....        BL       LCD_WriteData
   1363                pu8Icon++;
   \       0x72   0x1C64             ADDS     R4,R4,#+1
   1364              }
   \       0x74   0x1C6D             ADDS     R5,R5,#+1
   \       0x76   0xE7F4             B        ??LCD_DrawIcon_5
   1365            }
   \                     ??LCD_DrawIcon_6: (+1)
   \       0x78   0x1C76             ADDS     R6,R6,#+1
   \       0x7A   0xE7CF             B        ??LCD_DrawIcon_3
   1366            
   1367          }
   \                     ??LCD_DrawIcon_4: (+1)
   \                     ??LCD_DrawIcon_2: (+1)
   \       0x7C   0xBCF1             POP      {R0,R4-R7}
   \       0x7E   0xBC08             POP      {R3}
   \       0x80   0x4718             BX       R3               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     mIsLcdInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     `LCD_ClearDisplay::linesToClear`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     mLineParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x0000'2710        DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0000'270F        DC32     0x270f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     gaHexValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x0000'2710        DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     gaHexValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     aLCDFont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     `LCD_ClearLine::isPageDeleted`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     `LCD_ClearLine::pageToDelete`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x....'....        DC32     mLineParams

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x46 0x6F          DC8 "Format unknow"
   \              0x72 0x6D    
   \              0x61 0x74    
   \              0x20 0x75    
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x53 0x69          DC8 83, 105, 122, 101, 32, 78, 111, 116, 32, 86, 97, 108, 105, 100, 42
   \              0x7A 0x65    
   \              0x20 0x4E    
   \              0x6F 0x74    
   \              0x20 0x56    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x2A         
   \        0xF   0x2A 0x00          DC8 42, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   1368          
   1369          #endif /* (gLCDSupported_d == 1) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GetData
        16   -> Gpio_GetPortData
       4   GetStrlen
      16   InitDisplayWrite
        16   -> LCD_WriteCommand
       0   LCD_CheckError
      24   LCD_ClearDisplay
        24   -> LCD_ClearLine
      16   LCD_ClearLine
        16   -> LCD_ClearPage
      24   LCD_ClearPage
        24   -> InitDisplayWrite
        24   -> LCD_WriteData
      24   LCD_DrawIcon
        24   -> LCD_WriteCommand
        24   -> LCD_WriteData
      16   LCD_Init
        16   -> DelayMs
        16   -> DelayUs
        16   -> Gpio_SetPinData
        16   -> Gpio_SetPinDir
        16   -> Gpio_SetPinFunction
        16   -> Gpio_SetPinReadSource
        16   -> Gpio_SetPortDir
        16   -> Gpio_SetPortFunction
        16   -> Gpio_WrPortSetting
        16   -> LCD_SetBacklight
        16   -> LCD_SetFont
        16   -> LCD_WriteCommand
      16   LCD_SetBacklight
        16   -> Gpio_SetPinData
       4   LCD_SetFont
      80   LCD_WriteBytes
        80   -> LCD_WriteString
        80   -> __aeabi_memcpy4
      40   LCD_WriteCharacter
        40   -> InitDisplayWrite
        40   -> LCD_WriteData
       8   LCD_WriteCommand
         8   -> DelayUs
         8   -> Gpio_SetPinData
         8   -> SendData
         8   -> SetHiZ
         8   -> SetOutput
       8   LCD_WriteData
         8   -> DelayUs
         8   -> Gpio_SetPinData
         8   -> SendData
         8   -> SetHiZ
         8   -> SetOutput
      32   LCD_WritePixel
        32   -> LCD_WriteCommand
        32   -> LCD_WriteData
        32   -> ReadData
        32 __aeabi_idivmod
      88   LCD_WriteStringDecValue
        88   -> LCD_WriteString_NormalFont
        88   -> __aeabi_memclr4
        88 __aeabi_idiv
        88 __aeabi_idivmod
      88   LCD_WriteStringValue
        88   -> LCD_WriteString_NormalFont
        88 __aeabi_idiv
        88 __aeabi_idivmod
      24   LCD_WriteString_NormalFont
        24   -> GetStrlen
        24   -> LCD_WriteCharacter
       8   ReadData
         8   -> DelayUs
         8   -> GetData
         8   -> Gpio_SetPinData
       8   SendData
         8   -> Gpio_SetPortData
       8   SetHiZ
         8   -> Gpio_SetPortDir
       8   SetOutput
         8   -> Gpio_SetPortDir


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
      16  ?_0
      20  ?_1
      24  ?_2
      44  GetData
      54  GetStrlen
      66  InitDisplayWrite
       6  LCD_CheckError
     144  LCD_ClearDisplay
     130  LCD_ClearLine
      58  LCD_ClearPage
     130  LCD_DrawIcon
     494  LCD_Init
      38  LCD_SetBacklight
      34  LCD_SetFont
     308  LCD_WriteBytes
     256  LCD_WriteCharacter
      86  LCD_WriteCommand
      86  LCD_WriteData
     228  LCD_WritePixel
     668  LCD_WriteStringDecValue
     678  LCD_WriteStringValue
      98  LCD_WriteString_NormalFont
      78  ReadData
      46  SendData
      30  SetHiZ
      26  SetOutput
      24  aLCDFont
      20  gaHexValue
       1  isPageDeleted
       1  linesToClear
     184  mDisplayParams
       1  mErrorIndicator
       1  mIsLcdInitialized
      24  mLineParams
       4  pageToDelete

 
     7 bytes in section .bss
   209 bytes in section .data
   104 bytes in section .rodata
 3 866 bytes in section .text
 
 3 866 bytes of CODE  memory
   104 bytes of CONST memory
   216 bytes of DATA  memory

Errors: none
Warnings: none
